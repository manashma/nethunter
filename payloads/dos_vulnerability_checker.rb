# Description: Checks for common DoS vulnerabilities and identifies if systems are susceptible to various DoS attack types
# Author: dorazombiiee

class DosVulnerabilityChecker
  def initialize
    @results = {
      vulnerable_services: [],
      potential_attacks: [],
      summary: {
        is_vulnerable: false,
        risk_level: "Low",
        recommendations: []
      }
    }
    
    # Define DoS attack vectors and their associated port/service mappings
    @attack_vectors = {
      "SYN Flood" => [80, 443, 8080, 8443],
      "UDP Flood" => [53, 123, 161, 389],
      "TCP Amplification" => [80, 443, 25, 23],
      "HTTP/HTTPS Flood" => [80, 443, 8080, 8443],
      "Slowloris" => [80, 443, 8080],
      "ICMP Flood" => [:all],
      "Connection Exhaustion" => [21, 22, 23, 25, 80, 443, 3389],
      "DNS Amplification" => [53],
      "NTP Amplification" => [123],
      "SSDP Amplification" => [1900],
      "Memcached Amplification" => [11211]
    }
  end
  
  def run(target, open_ports, options)
    puts "[*] Starting DoS vulnerability check on #{target}...".blue
    
    # Check for rate limiting and connection throttling
    check_rate_limiting(target, open_ports)
    
    # Check for specific service vulnerabilities
    check_service_vulnerabilities(target, open_ports)
    
    # Calculate risk score
    calculate_risk_level
    
    # Generate recommendations
    generate_recommendations
    
    puts "[+] DoS vulnerability check complete.".green
    puts "  Risk Level: #{@results[:summary][:risk_level]}".colorize(risk_color)
    
    if @results[:potential_attacks].any?
      puts "  [!] Potentially vulnerable to the following DoS attacks:".yellow
      @results[:potential_attacks].each do |attack|
        puts "    - #{attack[:type]} on port #{attack[:port]} (#{attack[:service]})".yellow
      end
    else
      puts "  [+] No significant DoS vulnerabilities detected.".green
    end
    
    if options[:verbose]
      puts "\n[*] Detailed scan results:".blue
      puts "  Vulnerable Services: #{@results[:vulnerable_services].size}".blue
      puts "  Potential Attack Vectors: #{@results[:potential_attacks].size}".blue
      
      puts "\n[*] Recommendations:".blue
      @results[:summary][:recommendations].each do |rec|
        puts "  - #{rec}".blue
      end
    end
    
    # Return results
    @results
  end
  
  private
  
  def risk_color
    case @results[:summary][:risk_level]
    when "Critical"
      :red
    when "High"
      :light_red
    when "Medium"
      :yellow
    when "Low"
      :green
    else
      :blue
    end
  end
  
  def check_rate_limiting(target, open_ports)
    web_ports = [80, 443, 8080, 8443]
    open_web_ports = open_ports.select { |port| web_ports.include?(port) }
    
    if open_web_ports.any?
      puts "[*] Testing rate limiting on web ports...".blue
      
      open_web_ports.each do |port|
        protocol = (port == 443 || port == 8443) ? "https" : "http"
        uri = URI.parse("#{protocol}://#{target}:#{port}/")
        
        # Test for rate limiting by sending multiple requests in quick succession
        connection_count = 0
        response_times = []
        rate_limited = false
        
        10.times do |i|
          begin
            start_time = Time.now
            
            http = Net::HTTP.new(uri.host, uri.port)
            http.use_ssl = (protocol == "https")
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE
            http.open_timeout = 2
            http.read_timeout = 2
            
            response = http.get('/', {'User-Agent' => 'NetHunter DoS Vulnerability Check'})
            
            end_time = Time.now
            response_time = (end_time - start_time) * 1000 # in ms
            response_times << response_time
            
            connection_count += 1
            
            # Check for signs of rate limiting in headers
            if response['x-ratelimit-remaining'] || 
               response['retry-after'] || 
               response.code == '429'
              rate_limited = true
              break
            end
            
            # Sleep for a short time to prevent actual DoS
            sleep(0.2)
          rescue => e
            # If connection fails after a few successful ones, might indicate rate limiting
            if connection_count > 0 && connection_count < 8
              rate_limited = true
            end
            break
          end
        end
        
        # Analyze response times for signs of throttling
        if response_times.size >= 3
          avg_first = response_times[0..2].sum / 3.0
          avg_last = response_times[-3..-1].sum / 3.0
          
          # If response times increased significantly, might indicate throttling
          if avg_last > avg_first * 2
            rate_limited = true
          end
        end
        
        if !rate_limited && connection_count >= 8
          @results[:vulnerable_services] << {
            port: port,
            service: "Web Server (#{protocol.upcase})",
            issue: "No rate limiting detected"
          }
          
          # Add potential attacks for this vulnerability
          @attack_vectors.each do |attack_type, attack_ports|
            if attack_ports.include?(port) || attack_ports.include?(:all)
              @results[:potential_attacks] << {
                type: attack_type,
                port: port,
                service: "Web Server (#{protocol.upcase})",
                details: "No rate limiting detected, potentially vulnerable to #{attack_type} attacks."
              }
            end
          end
        end
      end
    end
    
    # Check DNS amplification vulnerability (port 53)
    if open_ports.include?(53)
      puts "[*] Testing DNS service for amplification vulnerabilities...".blue
      begin
        # Try to send DNS query that could be used for amplification
        socket = UDPSocket.new
        socket.connect(target, 53)
        
        # Send a DNS query for "." with request for ANY records - typical amplification vector
        query = "\x00\x01\x01\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\xff\x00\x01"
        socket.send(query, 0)
        
        # Wait for response
        response = nil
        begin
          Timeout.timeout(2) do
            response = socket.recvfrom(1024)
          end
        rescue Timeout::Error
          # No response received
        end
        
        socket.close
        
        # If we got a response that's much larger than our query, it's potentially vulnerable to amplification
        if response && response[0].length > query.length * 5
          @results[:vulnerable_services] << {
            port: 53,
            service: "DNS",
            issue: "Potentially vulnerable to DNS amplification attacks"
          }
          
          @results[:potential_attacks] << {
            type: "DNS Amplification",
            port: 53,
            service: "DNS",
            details: "DNS server allows recursive queries and responds with large amplification factor."
          }
        end
      rescue => e
        # Error in testing
      end
    end
    
    # Check NTP amplification vulnerability (port 123)
    if open_ports.include?(123)
      puts "[*] Testing NTP service for amplification vulnerabilities...".blue
      begin
        # Try to send NTP monlist command - a typical amplification vector
        socket = UDPSocket.new
        socket.connect(target, 123)
        
        # monlist request packet
        monlist_request = "\x17\x00\x03\x2a\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
        socket.send(monlist_request, 0)
        
        # Wait for response
        response = nil
        begin
          Timeout.timeout(2) do
            response = socket.recvfrom(1024)
          end
        rescue Timeout::Error
          # No response received
        end
        
        socket.close
        
        # If we got a response that's much larger than our request, it's potentially vulnerable to amplification
        if response && response[0].length > monlist_request.length * 5
          @results[:vulnerable_services] << {
            port: 123,
            service: "NTP",
            issue: "Potentially vulnerable to NTP amplification attacks"
          }
          
          @results[:potential_attacks] << {
            type: "NTP Amplification",
            port: 123,
            service: "NTP",
            details: "NTP server responds to monlist commands with large amplification factor."
          }
        end
      rescue => e
        # Error in testing
      end
    end
  end
  
  def check_service_vulnerabilities(target, open_ports)
    # Check web server for Slowloris vulnerability
    web_ports = [80, 443, 8080, 8443]
    open_web_ports = open_ports.select { |port| web_ports.include?(port) }
    
    if open_web_ports.any?
      puts "[*] Testing web servers for Slowloris vulnerability...".blue
      
      open_web_ports.each do |port|
        protocol = (port == 443 || port == 8443) ? "https" : "http"
        connections = []
        vulnerable = false
        
        # Try to establish multiple partial HTTP connections
        begin
          5.times do |i|
            socket = TCPSocket.new(target, port)
            
            # Send partial HTTP request
            socket.puts("GET / HTTP/1.1")
            socket.puts("Host: #{target}")
            socket.puts("User-Agent: NetHunter DoS Vulnerability Check")
            # Don't complete the request, keep connection open
            
            connections << socket
            sleep(0.2)
          end
          
          # Wait to see if connections remain open
          sleep(2)
          
          # Check if connections are still open
          alive_count = connections.count { |socket| !socket.closed? && socket.stat }
          
          if alive_count >= 4
            vulnerable = true
            @results[:vulnerable_services] << {
              port: port,
              service: "Web Server (#{protocol.upcase})",
              issue: "Potentially vulnerable to Slowloris attack"
            }
            
            @results[:potential_attacks] << {
              type: "Slowloris",
              port: port,
              service: "Web Server (#{protocol.upcase})",
              details: "Server keeps partial connections open, potentially vulnerable to Slowloris attacks."
            }
          end
          
        rescue => e
          # Error in testing
        ensure
          # Close all open connections
          connections.each do |socket|
            socket.close rescue nil
          end
        end
      end
    end
    
    # Check for SYN flood vulnerability on common services
    syn_flood_ports = [21, 22, 23, 25, 80, 443, 3389]
    open_syn_ports = open_ports.select { |port| syn_flood_ports.include?(port) }
    
    if open_syn_ports.any?
      puts "[*] Testing services for SYN flood vulnerability...".blue
      
      # Check if any of these ports have no connection limiting
      open_syn_ports.each do |port|
        service_name = case port
                       when 21 then "FTP"
                       when 22 then "SSH"
                       when 23 then "Telnet"
                       when 25 then "SMTP"
                       when 80 then "HTTP"
                       when 443 then "HTTPS"
                       when 3389 then "RDP"
                       else "Unknown"
                       end
        
        # Test if we can establish multiple connections quickly
        connections = []
        connection_limit_detected = false
        
        begin
          10.times do
            socket = TCPSocket.new(target, port)
            connections << socket
            sleep(0.1)
          end
        rescue => e
          if connections.size < 8
            connection_limit_detected = true
          end
        ensure
          connections.each { |socket| socket.close rescue nil }
        end
        
        if !connection_limit_detected && connections.size >= 8
          @results[:vulnerable_services] << {
            port: port,
            service: service_name,
            issue: "No connection rate limiting detected"
          }
          
          @results[:potential_attacks] << {
            type: "SYN Flood",
            port: port,
            service: service_name,
            details: "Service allows rapid connection establishment without throttling."
          }
          
          @results[:potential_attacks] << {
            type: "Connection Exhaustion",
            port: port,
            service: service_name,
            details: "Service allows many concurrent connections without limiting."
          }
        end
      end
    end
    
    # Check for Memcached amplification (port 11211)
    if open_ports.include?(11211)
      puts "[*] Testing Memcached for amplification vulnerabilities...".blue
      begin
        socket = TCPSocket.new(target, 11211)
        socket.puts("stats\r\n")
        response = socket.gets
        socket.close
        
        if response && response.include?("STAT")
          @results[:vulnerable_services] << {
            port: 11211,
            service: "Memcached",
            issue: "Potentially vulnerable to Memcached amplification attacks"
          }
          
          @results[:potential_attacks] << {
            type: "Memcached Amplification",
            port: 11211,
            service: "Memcached",
            details: "Memcached server accessible and responding to commands."
          }
        end
      rescue => e
        # Error in testing
      end
    end
    
    # Additional UDP reflection/amplification checks for SSDP (port 1900)
    if open_ports.include?(1900)
      puts "[*] Testing SSDP for amplification vulnerabilities...".blue
      begin
        socket = UDPSocket.new
        socket.connect(target, 1900)
        
        # M-SEARCH request that would be used in amplification
        msearch = "M-SEARCH * HTTP/1.1\r\nHOST: 239.255.255.250:1900\r\nMAN: \"ssdp:discover\"\r\nMX: 1\r\nST: ssdp:all\r\n\r\n"
        socket.send(msearch, 0)
        
        response = nil
        begin
          Timeout.timeout(2) do
            response = socket.recvfrom(1024)
          end
        rescue Timeout::Error
          # No response received
        end
        
        socket.close
        
        if response && response[0].length > msearch.length * 2
          @results[:vulnerable_services] << {
            port: 1900,
            service: "SSDP",
            issue: "Potentially vulnerable to SSDP amplification attacks"
          }
          
          @results[:potential_attacks] << {
            type: "SSDP Amplification",
            port: 1900,
            service: "SSDP",
            details: "SSDP service responds to discovery requests with amplified responses."
          }
        end
      rescue => e
        # Error in testing
      end
    end
  end
  
  def calculate_risk_level
    # Calculate overall risk level based on findings
    attack_count = @results[:potential_attacks].size
    service_count = @results[:vulnerable_services].size
    
    # Critical attacks - check if particularly dangerous DoS vectors are present
    critical_attacks = ["DNS Amplification", "NTP Amplification", "Memcached Amplification", "SSDP Amplification"]
    has_critical = @results[:potential_attacks].any? { |attack| critical_attacks.include?(attack[:type]) }
    
    if has_critical && attack_count >= 2
      @results[:summary][:risk_level] = "Critical"
      @results[:summary][:is_vulnerable] = true
    elsif attack_count >= 3
      @results[:summary][:risk_level] = "High"
      @results[:summary][:is_vulnerable] = true
    elsif attack_count >= 1
      @results[:summary][:risk_level] = "Medium"
      @results[:summary][:is_vulnerable] = true
    else
      @results[:summary][:risk_level] = "Low"
      @results[:summary][:is_vulnerable] = false
    end
  end
  
  def generate_recommendations
    # Generate recommendations based on findings
    if @results[:potential_attacks].any?
      @results[:summary][:recommendations] << "Implement rate limiting and connection throttling on all public-facing services."
      
      # Web server specific recommendations
      if @results[:potential_attacks].any? { |a| a[:type] == "Slowloris" || a[:type] == "HTTP/HTTPS Flood" }
        @results[:summary][:recommendations] << "Configure web server to limit concurrent connections per IP and implement connection timeout policies."
        @results[:summary][:recommendations] << "Consider implementing a web application firewall (WAF) to filter malicious traffic."
      end
      
      # DNS specific recommendations
      if @results[:potential_attacks].any? { |a| a[:type] == "DNS Amplification" }
        @results[:summary][:recommendations] << "Configure DNS server to disable recursive queries from external sources or implement response rate limiting."
      end
      
      # NTP specific recommendations
      if @results[:potential_attacks].any? { |a| a[:type] == "NTP Amplification" }
        @results[:summary][:recommendations] << "Update NTP server and disable monlist command or restrict to trusted IPs only."
      end
      
      # General recommendations for all vulnerable services
      @results[:summary][:recommendations] << "Deploy DoS protection services or hardware (e.g., DDoS mitigation appliances, CDN services)."
      @results[:summary][:recommendations] << "Implement ingress filtering at network edge to drop spoofed packets."
      @results[:summary][:recommendations] << "Consider implementing SYN cookies and TCP connection validation."
    else
      @results[:summary][:recommendations] << "Continue monitoring for new vulnerabilities and maintain current security posture."
    end
  end
end
