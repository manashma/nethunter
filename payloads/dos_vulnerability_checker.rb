# Description: Checks for common DoS vulnerabilities and identifies if systems are susceptible to various DoS attack types
# Author: dorazombiiee

require 'net/ssh'

class DosVulnerabilityChecker
  def initialize
    @results = {
      vulnerable_services: [],
      potential_attacks: [],
      summary: {
        is_vulnerable: false,
        risk_level: "Low",
        recommendations: []
      }
    }
    
    @attack_vectors = {
      "SYN Flood" => [80, 443, 8080, 8443],
      "UDP Flood" => [53, 123, 161, 389],
      "TCP Amplification" => [80, 443, 25, 23],
      "HTTP/HTTPS Flood" => [80, 443, 8080, 8443],
      "Slowloris" => [80, 443, 8080],
      "ICMP Flood" => [:all],
      "Connection Exhaustion" => [21, 22, 23, 25, 80, 443, 3389],
      "DNS Amplification" => [53],
      "NTP Amplification" => [123],
      "SSDP Amplification" => [1900],
      "Memcached Amplification" => [11211]
    }
    
    @service_thresholds = {
      "HTTP" => { max_connections: 30, baseline_response_time: nil, connection_variance_threshold: 0.3 },
      "HTTPS" => { max_connections: 30, baseline_response_time: nil, connection_variance_threshold: 0.3 },
      "DNS" => { amplification_factor: 10 },
      "NTP" => { amplification_factor: 10 },
      "SSDP" => { amplification_factor: 8 },
      "Memcached" => { amplification_factor: 10 }
    }
    
    @enterprise_patterns = [
      /\.(gov|edu|mil)$/i,
      /google|amazon|microsoft|cloudflare|akamai|fastly|facebook|twitter|instagram|linkedin|netflix|apple|github/i,
      /shopify|salesforce|oracle|ibm|adobe|sap|vmware|cisco|juniper|fortinet|paloalto|aws|azure|gcp/i,
      /cloudfront|azurewebsites|herokuapp|000webhost|netlify|vercel|digitalocean|linode|vultr/i,
      /cdn|content-delivery|edge|cache/i
    ]
  end
  
  def run(target, open_ports, options)
    puts "[*] Starting DoS vulnerability check on #{target}..."
    
    if is_enterprise_target?(target)
      puts "[!] Target appears to be an enterprise service with built-in DoS protection."
      apply_enterprise_profile(target)
      return @results
    end
    
    establish_baselines(target, open_ports)
    check_rate_limiting(target, open_ports)
    check_service_vulnerabilities(target, open_ports)
    
    detect_protection_mechanisms(target, open_ports)
    validate_findings(target)
    calculate_risk_level
    generate_recommendations
    
    puts "[+] DoS vulnerability check complete."
    puts "  Risk Level: #{@results[:summary][:risk_level]}"
    
    if @results[:potential_attacks].any?
      puts "  [!] Potentially vulnerable to the following DoS attacks:"
      @results[:potential_attacks].each do |attack|
        puts "    - #{attack[:type]} on port #{attack[:port]} (#{attack[:service]})"
      end
    else
      puts "  [+] No significant DoS vulnerabilities detected."
    end
    
    if options[:verbose]
      puts "\n[*] Detailed scan results:"
      puts "  Vulnerable Services: #{@results[:vulnerable_services].size}"
      puts "  Potential Attack Vectors: #{@results[:potential_attacks].size}"
      
      puts "\n[*] Recommendations:"
      @results[:summary][:recommendations].each do |rec|
        puts "  - #{rec}"
      end
    end
    
    @results
  end
  
  private
  
  def is_enterprise_target?(target)
    @enterprise_patterns.any? { |pattern| target.match(pattern) }
  end
  
  def apply_enterprise_profile(target)
    @results[:summary][:risk_level] = "Low"
    @results[:summary][:is_vulnerable] = false
    @results[:summary][:recommendations] << "Target appears to use enterprise-grade infrastructure with built-in DoS protection."
  end
  
  def establish_baselines(target, open_ports)
    web_ports = [80, 443, 8080, 8443]
    open_web_ports = open_ports.select { |port| web_ports.include?(port) }
    
    if open_web_ports.any?
      puts "[*] Establishing baseline response times..."
      
      open_web_ports.each do |port|
        protocol = (port == 443 || port == 8443) ? "https" : "http"
        service_key = (port == 443 || port == 8443) ? "HTTPS" : "HTTP"
        
        baseline_times = []
        response_codes = []
        
        10.times do |i|
          begin
            start_time = Time.now
            
            http = Net::HTTP.new(target, port)
            http.use_ssl = (protocol == "https")
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE
            http.open_timeout = 5
            http.read_timeout = 5
            
            paths = ['/', '/index.html', '/home', '/main', '/about']
            path = paths[i % paths.size]
            
            response = http.get(path, {'User-Agent' => "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/#{90 + i} Safari/537.36"})
            
            end_time = Time.now
            response_time = (end_time - start_time) * 1000
            baseline_times << response_time
            response_codes << response.code
            
            sleep(0.3)
          rescue => e
            # Skip failed requests
          end
        end
        
        if baseline_times.size >= 6
          baseline_times.sort!
          trimmed_times = baseline_times[2...-2]
          @service_thresholds[service_key][:baseline_response_time] = {
            avg: trimmed_times.sum / trimmed_times.size,
            min: trimmed_times.min,
            max: trimmed_times.max,
            variance: calculate_variance(trimmed_times)
          }
          
          @service_thresholds[service_key][:baseline_status_codes] = response_codes.tally
        end
      end
    end
  end
  
  def calculate_variance(values)
    return 0 if values.empty?
    mean = values.sum / values.size.to_f
    sum_squared_deviations = values.map { |v| (v - mean) ** 2 }.sum
    sum_squared_deviations / values.size.to_f
  end
  
  def check_rate_limiting(target, open_ports)
    web_ports = [80, 443, 8080, 8443]
    open_web_ports = open_ports.select { |port| web_ports.include?(port) }
    
    if open_web_ports.any?
      puts "[*] Testing rate limiting on web ports..."
      
      open_web_ports.each do |port|
        protocol = (port == 443 || port == 8443) ? "https" : "http"
        service_key = (port == 443 || port == 8443) ? "HTTPS" : "HTTP"
        
        if @service_thresholds[service_key][:baseline_response_time].nil?
          next
        end
        
        detect_web_protection(target, port, protocol)
        
        response_patterns = []
        rate_limited = false
        has_rate_limit_headers = false
        
        last_successful_response = nil
        
        # Check for rate limit headers
        begin
          http = Net::HTTP.new(target, port)
          http.use_ssl = (protocol == "https")
          http.verify_mode = OpenSSL::SSL::VERIFY_NONE
          http.open_timeout = 5
          http.read_timeout = 5
          
          response = http.get('/', {'User-Agent' => 'Mozilla/5.0'})
          last_successful_response = response
          
          rate_limit_headers = [
            'x-ratelimit-limit', 'x-ratelimit-remaining', 'x-ratelimit-reset', 'retry-after', 
            'ratelimit-limit', 'ratelimit-remaining', 'ratelimit-reset', 'x-rate-limit-limit',
            'x-rate-limit-remaining', 'x-rate-limit-reset', 'x-ratelimit', 'x-rate-limit'
          ]
          
          rate_limit_headers.each do |header|
            if response.key?(header.downcase)
              has_rate_limit_headers = true
              rate_limited = true
              break
            end
          end
        rescue => e
        end
        
        # Standard rate limit detection if headers not found
        unless rate_limited
          burst_sizes = [10, 20, 50]
          time_windows = [1, 3, 5] # seconds
          
          burst_sizes.each do |burst_size|
            time_windows.each do |window|
              # Skip further testing if we already detected rate limiting
              break if rate_limited
              
              responses = []
              threads = []
              request_start = Time.now
              
              # Make requests in parallel bursts
              burst_size.times do |i|
                threads << Thread.new do
                  begin
                    http = Net::HTTP.new(target, port)
                    http.use_ssl = (protocol == "https")
                    http.verify_mode = OpenSSL::SSL::VERIFY_NONE
                    http.open_timeout = 3
                    http.read_timeout = 3
                    
                    # Randomize paths slightly to avoid caching
                    path = "/?q=#{i}-#{SecureRandom.hex(4)}"
                    
                    # Randomize user agents
                    user_agent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/#{90 + i % 10} Safari/537.36"
                    
                    start_time = Time.now
                    response = http.get(path, {'User-Agent' => user_agent})
                    end_time = Time.now
                    
                    responses << {
                      code: response.code,
                      time: (end_time - start_time) * 1000,
                      headers: response.to_hash,
                      body_size: response.body.size
                    }
                  rescue => e
                    responses << {
                      error: e.message,
                      time: 3000 # Timeout
                    }
                  end
                end
              end
              
              threads.each(&:join)
              request_end = Time.now
              request_duration = request_end - request_start
              
              # Analyze responses
              response_codes = responses.map { |r| r[:code] }.compact.tally
              error_count = responses.count { |r| r[:error] }
              success_count = responses.count { |r| r[:code] == "200" }
              
              # Check for 429 Too Many Requests
              if response_codes["429"] && response_codes["429"] > burst_size / 5
                rate_limited = true
                response_patterns << "429 status codes detected"
                next
              end
              
              # Check for 503 Service Unavailable
              if response_codes["503"] && response_codes["503"] > burst_size / 5
                rate_limited = true
                response_patterns << "503 status codes detected"
                next
              end
              
              # Calculate response time differences
              if responses.size > 5
                times = responses.map { |r| r[:time] }.compact
                if times.any?
                  avg_time = times.sum / times.size
                  baseline = @service_thresholds[service_key][:baseline_response_time][:avg]
                  
                  # If response times increased significantly (more than 200%), might indicate throttling
                  if avg_time > baseline * 3
                    rate_limited = true
                    response_patterns << "response time increased by #{(avg_time / baseline).round(1)}x"
                    next
                  end
                end
              end
              
              # If we got many errors, it might be rate limiting
              if error_count > burst_size / 3
                rate_limited = true
                response_patterns << "#{error_count} connection errors"
                next
              end
              
              # Check for inconsistent body sizes (might indicate different responses due to rate limiting)
              if responses.size > 5
                body_sizes = responses.map { |r| r[:body_size] }.compact
                unique_sizes = body_sizes.uniq
                
                if unique_sizes.size > 1 && unique_sizes.size >= burst_size / 3
                  # Too many different response sizes might indicate different error pages/redirects
                  rate_limited = true
                  response_patterns << "inconsistent response sizes"
                  next
                end
              end
              
              # Check if real request rate was significantly lower than intended
              # (indicating connection throttling on server side)
              target_rate = burst_size / window.to_f
              actual_rate = burst_size / [request_duration, 0.1].max
              
              if actual_rate < target_rate * 0.7 && success_count < burst_size * 0.7
                rate_limited = true
                response_patterns << "connection throttling detected"
              end
            end
          end
        end
        
        # Extract server information for more accurate assessment
        server_info = last_successful_response&.[]('server')
        waf_info = last_successful_response&.[]('x-powered-by') || 
                   last_successful_response&.[]('x-generator') ||
                   last_successful_response&.[]('x-waf')
        
        # Detect WAF presence from response patterns
        known_waf_patterns = [
          /cloudflare|cloudfront|akamai|fastly|incapsula|sucuri|f5|imperva|distil|fortiweb|barracuda/i,
          /citrix|radware|aws|azure|gcp|wordfence|modsecurity|comodo|armor|prophaze|cdnjs/i
        ]
        
        has_waf = false
        
        if server_info
          has_waf ||= known_waf_patterns.any? { |pattern| server_info.match?(pattern) }
        end
        
        if waf_info
          has_waf ||= known_waf_patterns.any? { |pattern| waf_info.match?(pattern) }
        end
        
        if has_waf
          rate_limited = true
        end
        
        if rate_limited || has_rate_limit_headers || has_waf
          # Target has protection
          puts "  [+] Detected rate limiting/protection on port #{port} (#{protocol.upcase})"
          next
        else
          confidence = "Medium"
          
          if response_patterns.empty?
            confidence = "High"
          end
          
          @results[:vulnerable_services] << {
            port: port,
            service: "Web Server (#{protocol.upcase})",
            issue: "No rate limiting detected (Confidence: #{confidence})",
            evidence: response_patterns.empty? ? "No protection mechanisms detected" : response_patterns.join(", ")
          }
          
          relevant_attacks = ["HTTP/HTTPS Flood"]
          relevant_attacks << "SYN Flood" if confidence == "High"
          
          relevant_attacks.each do |attack_type|
            @results[:potential_attacks] << {
              type: attack_type,
              port: port,
              service: "Web Server (#{protocol.upcase})",
              details: "No effective rate limiting or DoS protection detected. #{response_patterns.join(", ")}",
              confidence: confidence
            }
          end
        end
      end
    end
    
    # Check for DNS amplification vulnerability with improved accuracy
    if open_ports.include?(53)
      puts "[*] Testing DNS service for amplification vulnerabilities..."
      
      amplification_detected = false
      max_amplification = 0
      valid_responses = 0
      
      query_types = [
        {
          name: "ANY",
          domains: ["example.com", "google.com", "microsoft.com", "openai.com"],
          data: "\x00\x01\x01\x00\x00\x01\x00\x00\x00\x00\x00\x00\x07\x65\x78\x61\x6d\x70\x6c\x65\x03\x63\x6f\x6d\x00\x00\xff\x00\x01"
        },
        {
          name: "TXT",
          domains: ["example.com", "google.com", "microsoft.com", "openai.com"],
          data: "\x00\x02\x01\x00\x00\x01\x00\x00\x00\x00\x00\x00\x07\x65\x78\x61\x6d\x70\x6c\x65\x03\x63\x6f\x6d\x00\x00\x10\x00\x01"
        },
        {
          name: "DNSKEY",
          domains: ["example.com", "google.com", "microsoft.com", "openai.com"],
          data: "\x00\x03\x01\x00\x00\x01\x00\x00\x00\x00\x00\x00\x07\x65\x78\x61\x6d\x70\x6c\x65\x03\x63\x6f\x6d\x00\x00\x30\x00\x01"
        }
      ]
      
      query_types.each do |query|
        socket = UDPSocket.new
        socket.connect(target, 53)
        
        socket.send(query[:data], 0)
        
        response = nil
        begin
          Timeout.timeout(2) do
            response = socket.recvfrom(4096)
          end
        rescue Timeout::Error
          # No response received
        rescue => e
          # Other error
        ensure
          socket.close rescue nil
        end
        
        if response && response[0].length > 0
          valid_responses += 1
          amplification = response[0].length.to_f / query[:data].length.to_f
          max_amplification = [max_amplification, amplification].max
          
          if amplification > @service_thresholds["DNS"][:amplification_factor]
            amplification_detected = true
          end
        end
      end
      
      # Only mark as vulnerable if we got multiple successful amplified responses
      if amplification_detected && valid_responses >= 2 && max_amplification > @service_thresholds["DNS"][:amplification_factor]
        confidence = max_amplification > 20 ? "High" : (max_amplification > 15 ? "Medium" : "Low")
        
        @results[:vulnerable_services] << {
          port: 53,
          service: "DNS",
          issue: "Vulnerable to DNS amplification (Factor: #{max_amplification.round(1)}x)",
          evidence: "#{valid_responses} successful amplified responses, max factor #{max_amplification.round(1)}x"
        }
        
        @results[:potential_attacks] << {
          type: "DNS Amplification",
          port: 53,
          service: "DNS",
          details: "DNS amplification factor of #{max_amplification.round(1)}x detected with #{valid_responses} valid query types.",
          confidence: confidence
        }
      end
    end
    
    # Similar improvements for NTP, SSDP, and Memcached checks
    check_ntp_amplification(target, open_ports)
    check_ssdp_amplification(target, open_ports)
    check_memcached_amplification(target, open_ports)
  end
  
  def detect_web_protection(target, port, protocol)
    # Try to detect if common protection systems are in place by checking headers
    begin
      http = Net::HTTP.new(target, port)
      http.use_ssl = (protocol == "https")
      http.verify_mode = OpenSSL::SSL::VERIFY_NONE
      http.open_timeout = 5
      http.read_timeout = 5
      
      response = http.get('/', {'User-Agent' => 'Mozilla/5.0'})
      
      # Common security headers that indicate security infrastructure
      security_headers = [
        'x-xss-protection', 'x-content-type-options', 'x-frame-options',
        'strict-transport-security', 'content-security-policy',
        'x-powered-by', 'server', 'x-generator', 'x-drupal-cache',
        'x-varnish', 'via', 'cf-ray', 'cf-cache-status', 'x-cache',
        'x-edge-location', 'x-amz-cf-id', 'x-waf-id', 'x-akamai-id'
      ]
      
      found_headers = []
      
      security_headers.each do |header|
        if response.key?(header.downcase)
          found_headers << "#{header}: #{response[header.downcase]}"
        end
      end
      
      # Check for WAF fingerprints
      waf_signatures = {
        cloudflare: [/cf-ray/i, /cloudflare/i],
        cloudfront: [/x-amz-cf-id/i],
        akamai: [/akamai/i, /x-akamai-transformed/i],
        fastly: [/fastly/i, /x-served-by.*fastly/i],
        incapsula: [/incapsula/i, /x-cdn: Incapsula/i],
        sucuri: [/sucuri/i],
        f5: [/f5/i, /bigip/i],
        imperva: [/imperva/i]
      }
      
      waf_found = nil
      
      waf_signatures.each do |waf, patterns|
        if patterns.any? { |pattern| found_headers.any? { |h| h.match?(pattern) } }
          waf_found = waf.to_s
          break
        end
      end
      
      if waf_found
        puts "  [+] Detected WAF: #{waf_found} on port #{port}"
        return true
      elsif found_headers.size >= 3
        puts "  [+] Detected multiple security headers on port #{port}"
        return true
      end
      
    rescue => e
      # Error checking headers
    end
    
    false
  end
  
  def check_ntp_amplification(target, open_ports)
    if open_ports.include?(123)
      puts "[*] Testing NTP service for amplification vulnerabilities..."
      
      ntp_commands = [
        # monlist request (high amplification)
        "\x17\x00\x03\x2a\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",
        # get_restrict request (medium amplification)
        "\x16\x02\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",
        # peers request (medium amplification)
        "\x16\x02\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
      ]
      
      max_amplification = 0
      amplification_detected = false
      valid_responses = 0
      
      ntp_commands.each do |cmd|
        3.times do
          begin
            socket = UDPSocket.new
            socket.connect(target, 123)
            socket.send(cmd, 0)
            
            response = nil
            begin
              Timeout.timeout(2) do
                response = socket.recvfrom(8192)
              end
            rescue Timeout::Error
              # No response received
            rescue => e
              # Other error
            ensure
              socket.close rescue nil
            end
            
            if response && response[0].length > 0
              valid_responses += 1
              amplification = response[0].length.to_f / cmd.length.to_f
              max_amplification = [max_amplification, amplification].max
              
              if amplification > @service_thresholds["NTP"][:amplification_factor]
                amplification_detected = true
              end
            end
            
            sleep(0.3)
          rescue => e
            # Error in testing
          end
        end
      end
      
      if amplification_detected && valid_responses >= 2 && max_amplification > @service_thresholds["NTP"][:amplification_factor]
        confidence = max_amplification > 30 ? "High" : (max_amplification > 20 ? "Medium" : "Low")
        
        @results[:vulnerable_services] << {
          port: 123,
          service: "NTP",
          issue: "Vulnerable to NTP amplification (Factor: #{max_amplification.round(1)}x)",
          evidence: "#{valid_responses} successful amplified responses, max factor #{max_amplification.round(1)}x"
        }
        
        @results[:potential_attacks] << {
          type: "NTP Amplification",
          port: 123,
          service: "NTP",
          details: "NTP amplification factor of #{max_amplification.round(1)}x detected with #{valid_responses} valid command types.",
          confidence: confidence
        }
      end
    end
  end
  
  def check_ssdp_amplification(target, open_ports)
    if open_ports.include?(1900)
      puts "[*] Testing SSDP for amplification vulnerabilities..."
      
      ssdp_queries = [
        # Standard M-SEARCH
        "M-SEARCH * HTTP/1.1\r\nHOST: 239.255.255.250:1900\r\nMAN: \"ssdp:discover\"\r\nMX: 1\r\nST: ssdp:all\r\n\r\n",
        # M-SEARCH with specific device type
        "M-SEARCH * HTTP/1.1\r\nHOST: 239.255.255.250:1900\r\nMAN: \"ssdp:discover\"\r\nMX: 1\r\nST: urn:schemas-upnp-org:device:InternetGatewayDevice:1\r\n\r\n",
        # M-SEARCH with media renderer
        "M-SEARCH * HTTP/1.1\r\nHOST: 239.255.255.250:1900\r\nMAN: \"ssdp:discover\"\r\nMX: 1\r\nST: urn:schemas-upnp-org:device:MediaRenderer:1\r\n\r\n"
      ]
      
      max_amplification = 0
      amplification_detected = false
      valid_responses = 0
      
      ssdp_queries.each do |query|
        2.times do
          begin
            socket = UDPSocket.new
            socket.connect(target, 1900)
            socket.send(query, 0)
            
            response = nil
            begin
              Timeout.timeout(2) do
                response = socket.recvfrom(8192)
              end
            rescue Timeout::Error
              # No response received
            rescue => e
              # Other error
            ensure
              socket.close rescue nil
            end
            
            if response && response[0].length > 0
              valid_responses += 1
              amplification = response[0].length.to_f / query.length.to_f
              max_amplification = [max_amplification, amplification].max
              
              if amplification > @service_thresholds["SSDP"][:amplification_factor]
                amplification_detected = true
              end
            end
            
            sleep(0.3)
          rescue => e
            # Error in testing
          end
        end
      end
      
      if amplification_detected && valid_responses >= 2 && max_amplification > @service_thresholds["SSDP"][:amplification_factor]
        confidence = max_amplification > 15 ? "High" : (max_amplification > 10 ? "Medium" : "Low")
        
        @results[:vulnerable_services] << {
          port: 1900,
          service: "SSDP",
          issue: "Vulnerable to SSDP amplification (Factor: #{max_amplification.round(1)}x)",
          evidence: "#{valid_responses} successful amplified responses, max factor #{max_amplification.round(1)}x"
        }
        
        @results[:potential_attacks] << {
          type: "SSDP Amplification",
          port: 1900,
          service: "SSDP",
          details: "SSDP amplification factor of #{max_amplification.round(1)}x detected with #{valid_responses} valid query types.",
          confidence: confidence
        }
      end
    end
  end
  
  def check_memcached_amplification(target, open_ports)
    if open_ports.include?(11211)
      puts "[*] Testing Memcached for amplification vulnerabilities..."
      
      memcached_commands = [
        # stats command (high amplification)
        "\x00\x01\x00\x00\x00\x01\x00\x00stats\r\n",
        # simple get command
        "\x00\x02\x00\x00\x00\x01\x00\x00get test\r\n"
      ]
      
      max_amplification = 0
      amplification_detected = false
      valid_responses = 0
      
      # Try UDP first (more dangerous for amplification)
      memcached_commands.each do |cmd|
        begin
          socket = UDPSocket.new
          socket.connect(target, 11211)
          socket.send(cmd, 0)
          
          response = nil
          begin
            Timeout.timeout(2) do
              response = socket.recvfrom(8192)
            end
          rescue Timeout::Error
            # No response received
          rescue => e
            # Other error
          ensure
            socket.close rescue nil
          end
          
          if response && response[0].length > 0
            valid_responses += 1
            amplification = response[0].length.to_f / cmd.length.to_f
            max_amplification = [max_amplification, amplification].max
            
            if amplification > @service_thresholds["Memcached"][:amplification_factor]
              amplification_detected = true
            end
          end
          
          sleep(0.3)
        rescue => e
          # Error in testing
        end
      end
      
      # Also check TCP (less common for amplification, but still informative)
      begin
        socket = TCPSocket.new(target, 11211)
        socket.write("stats\r\n")
        
        response = ""
        begin
          Timeout.timeout(2) do
            while line = socket.gets
              response += line
              break if line.strip == "END"
            end
          end
        rescue Timeout::Error
          # Timeout
        rescue => e
          # Other error
        ensure
          socket.close rescue nil
        end
        
        if response.length > 0
          valid_responses += 1
        end
      rescue => e
        # TCP connection failed
      end
      
      if amplification_detected && valid_responses >= 1 && max_amplification > @service_thresholds["Memcached"][:amplification_factor]
        confidence = max_amplification > 100 ? "High" : (max_amplification > 50 ? "Medium" : "Low")
        
        @results[:vulnerable_services] << {
          port: 11211,
          service: "Memcached",
          issue: "Vulnerable to Memcached amplification (Factor: #{max_amplification.round(1)}x)",
          evidence: "#{valid_responses} successful amplified responses, max factor #{max_amplification.round(1)}x"
        }
        
        @results[:potential_attacks] << {
          type: "Memcached Amplification",
          port: 11211,
          service: "Memcached",
          details: "Memcached amplification factor of #{max_amplification.round(1)}x detected with #{valid_responses} valid command types.",
          confidence: confidence
        }
      end
    end
  end
  
  def check_service_vulnerabilities(target, open_ports)
    # Check for TCP/IP-level vulnerabilities that are common across services
    puts "[*] Checking for TCP/IP level vulnerabilities..."
    
    # Test for SYN flood vulnerability on common service ports
    syn_flood_vulnerable_ports = []
    
    [80, 443, 22, 21, 25, 8080, 8443].each do |port|
      next unless open_ports.include?(port)
      
      # Simple connection flood test to see if server has flood protection
      successful = 0
      failed = 0
      timeouts = 0
      
      threads = []
      mutex = Mutex.new
      
      # Run multiple connections in parallel to simulate a partial SYN flood
      15.times do
        threads << Thread.new do
          begin
            socket = TCPSocket.new(target, port)
            # Just establish connection and close without completing handshake
            socket.close rescue nil
            
            mutex.synchronize { successful += 1 }
          rescue Errno::ETIMEDOUT, Timeout::Error
            mutex.synchronize { timeouts += 1 }
          rescue => e
            mutex.synchronize { failed += 1 }
          end
        end
      end
      
      threads.each { |t| t.join(3) }
      
      # Check if the service is potentially vulnerable to SYN flooding
      # High success rate without connection throttling might indicate vulnerability
      if successful > 10 && timeouts < 3 && failed < 3
        syn_flood_vulnerable_ports << port
      end
    end
    
    if syn_flood_vulnerable_ports.any?
      syn_flood_vulnerable_ports.each do |port|
        service_name = case port
                      when 80, 8080 then "HTTP"
                      when 443, 8443 then "HTTPS"
                      when 22 then "SSH"
                      when 21 then "FTP"
                      when 25 then "SMTP"
                      else "Unknown"
                      end
        
        @results[:vulnerable_services] << {
          port: port,
          service: service_name,
          issue: "Potentially vulnerable to SYN flood attacks",
          evidence: "No apparent connection rate limiting detected"
        }
        
        @results[:potential_attacks] << {
          type: "SYN Flood",
          port: port,
          service: service_name,
          details: "Service accepts large numbers of concurrent TCP connection attempts without apparent throttling",
          confidence: "Medium"
        }
      end
    end
    
    # Check for specific vulnerabilities by service type
    open_ports.each do |port|
      # Skip ports we've already thoroughly checked
      next if [80, 443, 8080, 8443, 53, 123, 1900, 11211].include?(port)
      
      case port
      when 21  # FTP
        check_ftp_vulnerabilities(target, port)
      when 22  # SSH 
        check_ssh_vulnerabilities(target, port)
      when 25  # SMTP
        check_smtp_vulnerabilities(target, port)
      when 161 # SNMP
        check_snmp_vulnerabilities(target, port)
      end
    end
  end
  
  def check_ftp_vulnerabilities(target, port)
    puts "[*] Testing FTP service (port #{port}) for DoS vulnerabilities..."
    
    # Check for anonymous login
    anonymous_login = false
    
    begin
      ftp = Net::FTP.new
      ftp.connect(target, port)
      ftp.login('anonymous', 'anonymous@test.com')
      anonymous_login = true
      ftp.close rescue nil
    rescue => e
      # Failed anonymous login
    end
    
    # Check if the server has connection limits by opening multiple connections
    max_connections = 0
    connection_throttling = false
    
    connections = []
    10.times do |i|
      begin
        ftp = Net::FTP.new
        ftp.connect(target, port)
        
        # Try to authenticate if anonymous login worked
        if anonymous_login
          ftp.login('anonymous', "anonymous#{i}@test.com")
        end
        
        connections << ftp
        max_connections += 1
        sleep(0.1)
      rescue => e
        # If we start getting connection errors after some successful connections,
        # it might indicate throttling or connection limits
        if max_connections > 0
          connection_throttling = true
        end
        break
      end
    end
    
    # Clean up connections
    connections.each { |ftp| ftp.close rescue nil }
    
    # Analyze results
    if max_connections >= 9
      @results[:vulnerable_services] << {
        port: port,
        service: "FTP",
        issue: "Potentially vulnerable to connection exhaustion attacks",
        evidence: "Server allowed #{max_connections} simultaneous connections without throttling"
      }
      
      @results[:potential_attacks] << {
        type: "Connection Exhaustion",
        port: port,
        service: "FTP",
        details: "FTP server accepts high numbers of concurrent connections (#{max_connections}+) without apparent limiting",
        confidence: "Medium"
      }
    end
  end
  
  def check_ssh_vulnerabilities(target, port)
    puts "[*] Testing SSH service (port #{port}) for DoS vulnerabilities..."
    
    # Test for rate limiting on authentication attempts
    rate_limited = false
    auth_attempts = 0
    
    # Try multiple rapid authentication attempts
    5.times do |i|
      begin
        start_time = Time.now
        
        ssh = Net::SSH.start(
          target,
          "testuser#{i}",
          password: "wrongpassword#{i}",
          non_interactive: true,
          auth_methods: ["password"],
          number_of_password_prompts: 1,
          timeout: 3
        )
        
        # If successful (unlikely), close connection
        ssh.close rescue nil
      rescue Net::SSH::AuthenticationFailed
        # Expected error, count as successful attempt
        auth_attempts += 1
      rescue Net::SSH::ConnectionTimeout, Timeout::Error
        # Server might be throttling after previous attempts
        rate_limited = true if auth_attempts > 0
        break
      rescue => e
        # Other errors (possibly indicating throttling or protection)
        if e.message =~ /too many authentication failures|connection reset|throttl|limit|wait|deny|block/i
          rate_limited = true
          break
        end
      end
      
      # Small delay to see if they're all accepted without rate limiting
      sleep(0.2)
    end
    
    if auth_attempts >= 3 && !rate_limited
      @results[:vulnerable_services] << {
        port: port,
        service: "SSH",
        issue: "Potentially vulnerable to authentication DoS attacks",
        evidence: "No apparent rate limiting on failed authentication attempts"
      }
      
      @results[:potential_attacks] << {
        type: "Authentication Flooding",
        port: port,
        service: "SSH",
        details: "SSH server appears to accept multiple rapid authentication attempts without rate limiting",
        confidence: "Medium"
      }
    end
  end
  
  def check_smtp_vulnerabilities(target, port)
    puts "[*] Testing SMTP service (port #{port}) for DoS vulnerabilities..."
    
    # Check for open relay and rate limiting
    open_relay = false
    rate_limited = false
    connection_limit_detected = false
    
    # Test multiple connections
    connections = []
    max_connections = 0
    
    10.times do |i|
      begin
        smtp = Net::SMTP.new(target, port)
        smtp.open_timeout = 3
        smtp.read_timeout = 3
        smtp.start('test.com')
        
        connections << smtp
        max_connections += 1
      rescue => e
        if max_connections > 0 && e.message =~ /connection|timeout|reset|refuse/i
          connection_limit_detected = true
        end
        break
      end
      
      sleep(0.2)
    end
    
    # Clean up connections
    connections.each { |smtp| smtp.finish rescue nil }
    
    if max_connections >= 8 && !connection_limit_detected
      @results[:vulnerable_services] << {
        port: port,
        service: "SMTP",
        issue: "Potentially vulnerable to connection exhaustion attacks",
        evidence: "Server allowed #{max_connections} simultaneous connections without throttling"
      }
      
      @results[:potential_attacks] << {
        type: "Connection Exhaustion",
        port: port,
        service: "SMTP",
        details: "SMTP server accepts high numbers of concurrent connections (#{max_connections}+) without apparent limiting",
        confidence: "Medium"
      }
    end
  end
  
  def check_snmp_vulnerabilities(target, port)
    puts "[*] Testing SNMP service (port #{port}) for DoS vulnerabilities..."
    
    # Test for publicly accessible SNMP with no/default community strings
    community_strings = ["public", "private", "community", "snmp", "cisco", "admin"]
    accessible = false
    
    community_strings.each do |community|
      begin
        manager = SNMP::Manager.new(host: target, port: port, community: community, timeout: 2, retries: 1)
        response = manager.get("1.3.6.1.2.1.1.1.0") # System description
        
        if response && response.varbind_list.first.value.to_s.length > 0
          accessible = true
          break
        end
      rescue => e
        # Error connecting or receiving data
      end
    end
    
    if accessible
      @results[:vulnerable_services] << {
        port: port,
        service: "SNMP",
        issue: "Publicly accessible SNMP service",
        evidence: "SNMP service responds to public community strings"
      }
      
      @results[:potential_attacks] << {
        type: "SNMP Amplification",
        port: port,
        service: "SNMP",
        details: "SNMP service is publicly accessible and could potentially be used for amplification attacks",
        confidence: "Medium"
      }
    end
  end
  
  def detect_protection_mechanisms(target, open_ports)
    puts "[*] Detecting protection mechanisms..."
    
    # Check if common protection mechanisms exist
    has_firewall = false
    has_rate_limiting = false
    has_load_balancing = false
    
    # Check for typical firewall responses (connection reset, timeouts, etc.)
    firewall_tests = [
      { port: 65534, protocol: 'TCP' },
      { port: 65533, protocol: 'UDP' }
    ]
    
    firewall_tests.each do |test|
      begin
        if test[:protocol] == 'TCP'
          socket = Socket.new(Socket::AF_INET, Socket::SOCK_STREAM, 0)
          sockaddr = Socket.sockaddr_in(test[:port], target)
          
          begin
            Timeout.timeout(2) do
              socket.connect(sockaddr)
            end
          rescue Timeout::Error
            # Expected timeout
          rescue Errno::ECONNREFUSED
            # Direct refusal, might not be a firewall
          rescue Errno::EHOSTUNREACH, Errno::ENETUNREACH
            # Network unreachable, likely firewall blocking
            has_firewall = true
          rescue Errno::ECONNRESET
            # Connection reset, likely firewall intervention
            has_firewall = true
          rescue => e
            # Other errors that might indicate firewall
            if e.message =~ /reset|refused|timeout|unreachable/i
              has_firewall = true
            end
          ensure
            socket.close rescue nil
          end
          
        elsif test[:protocol] == 'UDP'
          socket = UDPSocket.new
          socket.connect(target, test[:port])
          socket.send("PROBE", 0)
          
          begin
            Timeout.timeout(2) do
              response = socket.recvfrom(8)
              # Getting an ICMP error back might indicate firewall/filtering
              has_firewall = true if response
            end
          rescue Timeout::Error
            # Expected timeout for filtered port
          rescue Errno::ECONNREFUSED, Errno::EHOSTUNREACH, Errno::ENETUNREACH
            # Errors indicating filtering
            has_firewall = true
          end
          
          socket.close rescue nil
        end
      rescue => e
        # Other errors
      end
    end
    
    # Look for load balancing signs
    load_balancer_signatures = []
    
    # Check HTTP headers for load balancer signatures
    [80, 443].each do |port|
      next unless open_ports.include?(port)
      
      protocol = port == 443 ? "https" : "http"
      
      5.times do
        begin
          http = Net::HTTP.new(target, port)
          http.use_ssl = (protocol == "https")
          http.verify_mode = OpenSSL::SSL::VERIFY_NONE
          http.open_timeout = 3
          http.read_timeout = 3
          
          response = http.get('/', {'User-Agent' => "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/#{90 + rand(10)} Safari/537.36"})
          
          # Check for load balancer headers
          load_balancer_headers = [
            'x-served-by', 'x-cache', 'x-varnish', 'via', 'server', 'x-server',
            'x-powered-by', 'x-runtime', 'x-amz-cf-id', 'cf-ray', 'x-lb',
            'x-request-id', 'x-forwarded-for', 'x-forwarded-proto', 'x-forwarded-host'
          ]
          
          load_balancer_headers.each do |header|
            if response.key?(header.downcase) && !response[header.downcase].empty?
              lb_header = "#{header}: #{response[header.downcase]}"
              
              # Look for load balancer signatures
              if lb_header =~ /lb|load|balancer|cluster|node|pool|cdn|cache|edge/i
                load_balancer_signatures << lb_header
                has_load_balancing = true
              end
            end
          end
          
          # Check server header for load balancer software
          if response.key?('server')
            server = response['server']
            if server =~ /nginx|haproxy|aws|elb|f5|bigip|citrix|netscaler|cloudflare|cloudfront|akamai|varnish/i
              load_balancer_signatures << "Server: #{server}"
              has_load_balancing = true
            end
          end
          
          sleep(0.3)
        rescue => e
          # Skip errors
        end
      end
    end
    
    # Estimate protection level based on findings
    if has_firewall && has_load_balancing
      @results[:summary][:protection_level] = "High"
    elsif has_firewall || has_load_balancing
      @results[:summary][:protection_level] = "Medium"
    else
      @results[:summary][:protection_level] = "Low"
    end
    
    @results[:summary][:protection_detected] = {
      firewall: has_firewall,
      load_balancing: has_load_balancing,
      load_balancer_evidence: load_balancer_signatures
    }
  end
  
  def validate_findings(target)
    # Cross-check results and eliminate likely false positives
    @results[:potential_attacks].select! do |attack|
      # For amplification attacks, require a certain confidence level
      if attack[:type] =~ /Amplification/
        attack[:confidence] != "Low"
      else
        true
      end
    end
    
    # Enterprise targets are generally better protected
    if is_enterprise_target?(target)
      @results[:potential_attacks].reject! do |attack|
        attack[:confidence] == "Low" || 
        attack[:type] == "Connection Exhaustion" || 
        attack[:type] == "SYN Flood"
      end
    end
  end
  
  def calculate_risk_level
    # Calculate overall risk level based on findings
    if @results[:potential_attacks].empty?
      @results[:summary][:risk_level] = "Low"
      @results[:summary][:is_vulnerable] = false
      return
    end
    
    high_confidence_attacks = @results[:potential_attacks].count { |a| a[:confidence] == "High" }
    medium_confidence_attacks = @results[:potential_attacks].count { |a| a[:confidence] == "Medium" }
    
    # Prioritize dangerous amplification attacks
    amplification_attacks = @results[:potential_attacks].count { |a| a[:type] =~ /Amplification/ }
    
    if high_confidence_attacks >= 2 || (high_confidence_attacks >= 1 && amplification_attacks >= 1)
      @results[:summary][:risk_level] = "High"
      @results[:summary][:is_vulnerable] = true
    elsif medium_confidence_attacks >= 2 || high_confidence_attacks >= 1 || amplification_attacks >= 1
      @results[:summary][:risk_level] = "Medium"
      @results[:summary][:is_vulnerable] = true
    else
      @results[:summary][:risk_level] = "Low"
      @results[:summary][:is_vulnerable] = true
    end
  end
  
  def generate_recommendations
    if @results[:vulnerable_services].empty?
      @results[:summary][:recommendations] << "No significant DoS vulnerabilities detected. Continue monitoring security."
      return
    end
    
    # Generate specific recommendations based on vulnerabilities
    @results[:potential_attacks].each do |attack|
      case attack[:type]
      when "SYN Flood"
        @results[:summary][:recommendations] << "Enable SYN cookies or SYN flood protection on your firewall for port #{attack[:port]} (#{attack[:service]})."
        @results[:summary][:recommendations] << "Consider implementing a stateful firewall or DDoS protection service."
      
      when "HTTP/HTTPS Flood"
        @results[:summary][:recommendations] << "Implement rate limiting for HTTP/HTTPS requests on port #{attack[:port]}."
        @results[:summary][:recommendations] << "Consider using a CDN or WAF to filter malicious traffic."
      
      when /Amplification/
        service = attack[:type].split[0]
        case service
        when "DNS"
          @results[:summary][:recommendations] << "Disable DNS recursion if not required or restrict it to authorized clients only."
          @results[:summary][:recommendations] << "Configure DNS server to limit response sizes or queries per client."
        when "NTP"
          @results[:summary][:recommendations] << "Upgrade NTP server to a version that doesn't support monlist command."
          @results[:summary][:recommendations] << "Configure NTP server with 'noquery' option for unauthorized clients."
        when "SSDP"
          @results[:summary][:recommendations] << "Restrict SSDP service to internal networks only using proper firewall rules."
        when "Memcached"
          @results[:summary][:recommendations] << "Disable UDP support in Memcached if not required."
          @results[:summary][:recommendations] << "Bind Memcached only to internal interfaces and restrict access with firewall rules."
        end
      
      when "Connection Exhaustion"
        @results[:summary][:recommendations] << "Implement connection rate limiting for #{attack[:service]} on port #{attack[:port]}."
        @results[:summary][:recommendations] << "Configure maximum concurrent connection limits for #{attack[:service]} service."
      
      when "Authentication Flooding"
        @results[:summary][:recommendations] << "Implement authentication rate limiting and account lockout policies."
        @results[:summary][:recommendations] << "Consider using fail2ban or similar tools to temporarily block IPs with multiple failed login attempts."
      end
    end
    
    # General recommendations
    if @results[:summary][:risk_level] == "High" || @results[:summary][:risk_level] == "Medium"
      @results[:summary][:recommendations] << "Consider implementing a DDoS protection service or CDN."
      @results[:summary][:recommendations] << "Set up monitoring for network traffic anomalies and service disruptions."
    end
    
    # Remove duplicates
    @results[:summary][:recommendations].uniq!
  end
end
