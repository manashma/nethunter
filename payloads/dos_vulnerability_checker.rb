# Description: Checks for common DoS vulnerabilities and identifies if systems are susceptible to various DoS attack types
# Author: dorazombiiee

class DosVulnerabilityChecker
  def initialize
    @results = {
      vulnerable_services: [],
      potential_attacks: [],
      summary: {
        is_vulnerable: false,
        risk_level: "Low",
        recommendations: []
      }
    }
    
    @attack_vectors = {
      "SYN Flood" => [80, 443, 8080, 8443],
      "UDP Flood" => [53, 123, 161, 389],
      "TCP Amplification" => [80, 443, 25, 23],
      "HTTP/HTTPS Flood" => [80, 443, 8080, 8443],
      "Slowloris" => [80, 443, 8080],
      "ICMP Flood" => [:all],
      "Connection Exhaustion" => [21, 22, 23, 25, 80, 443, 3389],
      "DNS Amplification" => [53],
      "NTP Amplification" => [123],
      "SSDP Amplification" => [1900],
      "Memcached Amplification" => [11211]
    }
    
    @service_thresholds = {
      "HTTP" => { max_connections: 15, baseline_response_time: nil },
      "HTTPS" => { max_connections: 15, baseline_response_time: nil },
      "DNS" => { amplification_factor: 4 },
      "NTP" => { amplification_factor: 4 },
      "SSDP" => { amplification_factor: 3 },
      "Memcached" => { amplification_factor: 4 }
    }
  end
  
  def run(target, open_ports, options)
    puts "[*] Starting DoS vulnerability check on #{target}...".blue
    
    establish_baselines(target, open_ports)
    check_rate_limiting(target, open_ports)
    check_service_vulnerabilities(target, open_ports)
    calculate_risk_level
    generate_recommendations
    
    puts "[+] DoS vulnerability check complete.".green
    puts "  Risk Level: #{@results[:summary][:risk_level]}".colorize(risk_color)
    
    if @results[:potential_attacks].any?
      puts "  [!] Potentially vulnerable to the following DoS attacks:".yellow
      @results[:potential_attacks].each do |attack|
        puts "    - #{attack[:type]} on port #{attack[:port]} (#{attack[:service]})".yellow
      end
    else
      puts "  [+] No significant DoS vulnerabilities detected.".green
    end
    
    if options[:verbose]
      puts "\n[*] Detailed scan results:".blue
      puts "  Vulnerable Services: #{@results[:vulnerable_services].size}".blue
      puts "  Potential Attack Vectors: #{@results[:potential_attacks].size}".blue
      
      puts "\n[*] Recommendations:".blue
      @results[:summary][:recommendations].each do |rec|
        puts "  - #{rec}".blue
      end
    end
    
    @results
  end
  
  private
  
  def risk_color
    case @results[:summary][:risk_level]
    when "Critical" then :red
    when "High" then :light_red
    when "Medium" then :yellow
    when "Low" then :green
    else :blue
    end
  end
  
  def establish_baselines(target, open_ports)
    web_ports = [80, 443, 8080, 8443]
    open_web_ports = open_ports.select { |port| web_ports.include?(port) }
    
    if open_web_ports.any?
      puts "[*] Establishing baseline response times...".blue
      
      open_web_ports.each do |port|
        protocol = (port == 443 || port == 8443) ? "https" : "http"
        service_key = (port == 443 || port == 8443) ? "HTTPS" : "HTTP"
        
        baseline_times = []
        5.times do
          begin
            start_time = Time.now
            
            http = Net::HTTP.new(target, port)
            http.use_ssl = (protocol == "https")
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE
            http.open_timeout = 5
            http.read_timeout = 5
            
            response = http.get('/', {'User-Agent' => 'Mozilla/5.0'})
            
            end_time = Time.now
            response_time = (end_time - start_time) * 1000 # in ms
            baseline_times << response_time
            
            sleep(0.5)
          rescue => e
            # Skip failed requests
          end
        end
        
        if baseline_times.size >= 3
          # Remove outliers and calculate average
          baseline_times.sort!
          if baseline_times.size > 3
            baseline_times = baseline_times[1...-1] # Remove highest and lowest
          end
          @service_thresholds[service_key][:baseline_response_time] = baseline_times.sum / baseline_times.size
        end
      end
    end
  end
  
  def check_rate_limiting(target, open_ports)
    web_ports = [80, 443, 8080, 8443]
    open_web_ports = open_ports.select { |port| web_ports.include?(port) }
    
    if open_web_ports.any?
      puts "[*] Testing rate limiting on web ports...".blue
      
      open_web_ports.each do |port|
        protocol = (port == 443 || port == 8443) ? "https" : "http"
        service_key = (port == 443 || port == 8443) ? "HTTPS" : "HTTP"
        uri = URI.parse("#{protocol}://#{target}:#{port}/")
        
        connection_count = 0
        response_times = []
        rate_limited = false
        has_rate_limit_headers = false
        failures = 0
        
        # Perform an initial slow request to check for rate limit headers
        begin
          http = Net::HTTP.new(uri.host, uri.port)
          http.use_ssl = (protocol == "https")
          http.verify_mode = OpenSSL::SSL::VERIFY_NONE
          http.open_timeout = 5
          http.read_timeout = 5
          
          response = http.get('/', {'User-Agent' => 'Mozilla/5.0'})
          
          # Check for rate limit headers
          rate_limit_headers = [
            'x-ratelimit-limit', 'x-ratelimit-remaining', 'x-ratelimit-reset',
            'retry-after', 'ratelimit-limit', 'ratelimit-remaining', 'ratelimit-reset'
          ]
          
          if rate_limit_headers.any? { |h| response.key?(h.downcase) }
            has_rate_limit_headers = true
            rate_limited = true
          end
        rescue => e
          # Continue with the test
        end
        
        # Skip further testing if rate limiting was detected in headers
        unless rate_limited
          # Test with rapid requests
          20.times do |i|
            begin
              start_time = Time.now
              
              http = Net::HTTP.new(uri.host, uri.port)
              http.use_ssl = (protocol == "https")
              http.verify_mode = OpenSSL::SSL::VERIFY_NONE
              http.open_timeout = 3
              http.read_timeout = 3
              
              response = http.get('/', {'User-Agent' => "Mozilla/5.0 (DoS-Test-#{i})"})
              
              end_time = Time.now
              response_time = (end_time - start_time) * 1000 # in ms
              response_times << response_time
              
              connection_count += 1
              
              # Check for signs of rate limiting in response code or headers
              if response.code == '429' || response.code == '503' || 
                 response['retry-after'] || response['x-ratelimit-remaining'] == '0'
                rate_limited = true
                break
              end
              
              # Minimal delay to avoid actually DoSing the target
              sleep(0.1)
            rescue => e
              failures += 1
              # If we start seeing failures after successful connections, might be rate limiting
              if connection_count > 0 && failures >= 3
                rate_limited = true
                break
              end
            end
          end
          
          # Analyze response times for signs of throttling
          if response_times.size >= 10 && @service_thresholds[service_key][:baseline_response_time]
            baseline = @service_thresholds[service_key][:baseline_response_time]
            avg_first = response_times[0..4].sum / 5.0
            avg_last = response_times[-5..-1].sum / 5.0
            
            # If response times increased significantly (more than 3x), might indicate throttling
            if avg_last > avg_first * 3 || avg_last > baseline * 5
              rate_limited = true
            end
          end
        end
        
        # Consider enterprise-grade services having implicit protection
        enterprise_pattern = /\.(gov|edu|mil)$|google|amazon|microsoft|cloudflare|akamai|fastly/i
        if target.match(enterprise_pattern)
          # Large sites likely have protection even if we didn't detect it
          rate_limited = true unless connection_count > 15
        end
        
        unless rate_limited
          confidence_factor = connection_count >= 15 ? "High" : "Medium"
          
          @results[:vulnerable_services] << {
            port: port,
            service: "Web Server (#{protocol.upcase})",
            issue: "No rate limiting detected (Confidence: #{confidence_factor})"
          }
          
          # Add appropriate attack vectors based on the vulnerability
          relevant_attacks = ["HTTP/HTTPS Flood"]
          # Only add SYN Flood if we completed a high number of connections
          relevant_attacks << "SYN Flood" if connection_count >= 15
          
          relevant_attacks.each do |attack_type|
            @results[:potential_attacks] << {
              type: attack_type,
              port: port,
              service: "Web Server (#{protocol.upcase})",
              details: "No rate limiting detected with #{confidence_factor} confidence.",
              confidence: confidence_factor
            }
          end
        end
      end
    end
    
    # Check DNS amplification vulnerability (port 53)
    if open_ports.include?(53)
      puts "[*] Testing DNS service for amplification vulnerabilities...".blue
      begin
        # Send several different query types to test for amplification
        amplification_detected = false
        max_amplification = 0
        
        query_types = [
          # ANY query (common amplification vector)
          {
            data: "\x00\x01\x01\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\xff\x00\x01",
            name: "ANY"
          },
          # TXT query (potential amplification)
          {
            data: "\x00\x02\x01\x00\x00\x01\x00\x00\x00\x00\x00\x00\x07\x65\x78\x61\x6d\x70\x6c\x65\x03\x63\x6f\x6d\x00\x00\x10\x00\x01",
            name: "TXT"
          }
        ]
        
        query_types.each do |query|
          socket = UDPSocket.new
          socket.connect(target, 53)
          
          socket.send(query[:data], 0)
          
          response = nil
          begin
            Timeout.timeout(2) do
              response = socket.recvfrom(2048)
            end
          rescue Timeout::Error
            # No response received
          end
          
          socket.close
          
          # Calculate amplification factor
          if response && response[0].length > 0
            amplification = response[0].length.to_f / query[:data].length.to_f
            max_amplification = [max_amplification, amplification].max
            
            if amplification > @service_thresholds["DNS"][:amplification_factor]
              amplification_detected = true
            end
          end
        end
        
        if amplification_detected
          confidence = max_amplification > 10 ? "High" : "Medium"
          
          @results[:vulnerable_services] << {
            port: 53,
            service: "DNS",
            issue: "Vulnerable to DNS amplification (Factor: #{max_amplification.round(1)}x)"
          }
          
          @results[:potential_attacks] << {
            type: "DNS Amplification",
            port: 53,
            service: "DNS",
            details: "DNS amplification factor of #{max_amplification.round(1)}x detected.",
            confidence: confidence
          }
        end
      rescue => e
        # Error in testing
      end
    end
    
    # Check NTP amplification vulnerability (port 123)
    if open_ports.include?(123)
      puts "[*] Testing NTP service for amplification vulnerabilities...".blue
      begin
        # Try multiple NTP commands that could be used for amplification
        ntp_commands = [
          # monlist request
          "\x17\x00\x03\x2a\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",
          # get_restrict request
          "\x16\x02\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
        ]
        
        max_amplification = 0
        amplification_detected = false
        
        ntp_commands.each do |cmd|
          socket = UDPSocket.new
          socket.connect(target, 123)
          socket.send(cmd, 0)
          
          response = nil
          begin
            Timeout.timeout(2) do
              response = socket.recvfrom(2048)
            end
          rescue Timeout::Error
            # No response received
          end
          
          socket.close
          
          if response && response[0].length > 0
            amplification = response[0].length.to_f / cmd.length.to_f
            max_amplification = [max_amplification, amplification].max
            
            if amplification > @service_thresholds["NTP"][:amplification_factor]
              amplification_detected = true
            end
          end
        end
        
        if amplification_detected
          confidence = max_amplification > 10 ? "High" : "Medium"
          
          @results[:vulnerable_services] << {
            port: 123,
            service: "NTP",
            issue: "Vulnerable to NTP amplification (Factor: #{max_amplification.round(1)}x)"
          }
          
          @results[:potential_attacks] << {
            type: "NTP Amplification",
            port: 123,
            service: "NTP",
            details: "NTP amplification factor of #{max_amplification.round(1)}x detected.",
            confidence: confidence
          }
        end
      rescue => e
        # Error in testing
      end
    end
  end
  
  def check_service_vulnerabilities(target, open_ports)
    # Check web server for Slowloris vulnerability
    web_ports = [80, 443, 8080, 8443]
    open_web_ports = open_ports.select { |port| web_ports.include?(port) }
    
    if open_web_ports.any?
      puts "[*] Testing web servers for Slowloris vulnerability...".blue
      
      open_web_ports.each do |port|
        protocol = (port == 443 || port == 8443) ? "https" : "http"
        
        # First check if server software is known to be resilient to Slowloris
        begin
          http = Net::HTTP.new(target, port)
          http.use_ssl = (protocol == "https")
          http.verify_mode = OpenSSL::SSL::VERIFY_NONE
          http.open_timeout = 5
          http.read_timeout = 5
          
          response = http.head('/', {'User-Agent' => 'Mozilla/5.0'})
          server = response['server']
          
          # Skip testing if server is known to be resilient
          if server && (server.include?('nginx') || server.include?('cloudflare') || 
                        server.include?('IIS/8') || server.include?('IIS/10'))
            next
          end
        rescue => e
          # Continue with testing if we couldn't determine server type
        end
        
        # Test for Slowloris vulnerability
        connections = []
        max_connections = 0
        enterprise_pattern = /\.(gov|edu|mil)$|google|amazon|microsoft|cloudflare|akamai|fastly/i
        
        # Skip test for known enterprise sites
        if target.match(enterprise_pattern)
          next
        end
        
        # Try to establish multiple partial HTTP connections
        begin
          30.times do |i|
            socket = TCPSocket.new(target, port)
            
            # Send partial HTTP request
            socket.puts("GET / HTTP/1.1")
            socket.puts("Host: #{target}")
            socket.puts("User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)")
            # Add random header to keep connection open
            socket.puts("X-Header-#{i}: #{SecureRandom.hex(10)}")
            # Don't complete the request, keep connection open
            
            connections << socket
            max_connections = [max_connections, connections.size].max
            
            # Brief delay to avoid overwhelming target
            sleep(0.1)
          end
          
          # Wait to see if connections remain open
          sleep(3)
          
          # Check if connections are still open
          alive_count = connections.count do |socket| 
            begin
              !socket.closed? && socket.stat
            rescue
              false
            end
          end
          
          # Determine vulnerability based on connection survival ratio
          if alive_count >= 20
            confidence = "High"
            vulnerable = true
          elsif alive_count >= 10
            confidence = "Medium"
            vulnerable = true
          else
            vulnerable = false
          end
          
          if vulnerable
            @results[:vulnerable_services] << {
              port: port,
              service: "Web Server (#{protocol.upcase})",
              issue: "Vulnerable to Slowloris attack (#{alive_count}/#{max_connections} connections remained open)"
            }
            
            @results[:potential_attacks] << {
              type: "Slowloris",
              port: port,
              service: "Web Server (#{protocol.upcase})",
              details: "Server kept #{alive_count} partial connections open for extended period.",
              confidence: confidence
            }
          end
          
        rescue => e
          # Error in testing
        ensure
          # Close all open connections
          connections.each do |socket|
            begin
              socket.close unless socket.closed?
            rescue
              # Ignore errors during cleanup
            end
          end
        end
      end
    end
    
    # Check for connection limiting on important services
    connection_test_ports = [21, 22, 23, 25, 80, 443, 3389]
    open_test_ports = open_ports.select { |port| connection_test_ports.include?(port) }
    
    if open_test_ports.any?
      puts "[*] Testing services for connection limiting...".blue
      
      # Skip test for known enterprise sites
      enterprise_pattern = /\.(gov|edu|mil)$|google|amazon|microsoft|cloudflare|akamai|fastly/i
      unless target.match(enterprise_pattern)
        open_test_ports.each do |port|
          service_name = case port
                         when 21 then "FTP"
                         when 22 then "SSH"
                         when 23 then "Telnet"
                         when 25 then "SMTP"
                         when 80 then "HTTP"
                         when 443 then "HTTPS"
                         when 3389 then "RDP"
                         else "Unknown"
                         end
          
          # Test if we can establish multiple connections quickly
          connections = []
          max_concurrent = 0
          
          begin
            20.times do |i|
              socket = TCPSocket.new(target, port)
              connections << socket
              max_concurrent = [max_concurrent, connections.size].max
              
              # If SSH or similar, send initial data to keep connection
              if [22, 23, 25].include?(port)
                socket.puts("\r\n")
              end
              
              sleep(0.1)
            end
            
            # Wait briefly to see if server closes any connections
            sleep(2)
            
            # Count still-active connections
            alive_count = connections.count do |socket| 
              begin
                !socket.closed? && socket.stat
              rescue
                false
              end
            end
            
            # Determine if service has connection limiting
            if alive_count >= 15
              threshold = service_name == "SSH" ? 8 : 15
              if alive_count >= threshold
                confidence = "Medium"
                
                @results[:vulnerable_services] << {
                  port: port,
                  service: service_name,
                  issue: "No effective connection limiting (#{alive_count}/#{max_concurrent} connections remained open)"
                }
                
                @results[:potential_attacks] << {
                  type: "Connection Exhaustion",
                  port: port,
                  service: service_name,
                  details: "Service allowed #{alive_count} concurrent connections without limits.",
                  confidence: confidence
                }
              end
            end
          rescue => e
            # Error establishing connections may indicate protection
          ensure
            # Close all connections
            connections.each do |socket|
              begin
                socket.close unless socket.closed?
              rescue
                # Ignore errors during cleanup
              end
            end
          end
        end
      end
    end
    
    # Check for Memcached amplification (port 11211)
    if open_ports.include?(11211)
      puts "[*] Testing Memcached for amplification vulnerabilities...".blue
      begin
        # Try UDP first (more dangerous for amplification)
        socket = UDPSocket.new
        socket.connect(target, 11211)
        
        # stats command is used for amplification
        stats_cmd = "\x00\x01\x00\x00\x00\x01\x00\x00stats\r\n"
        socket.send(stats_cmd, 0)
        
        response = nil
        begin
          Timeout.timeout(2) do
            response = socket.recvfrom(4096)
          end
        rescue Timeout::Error
          # No response received
        end
        
        socket.close
        
        if response && response[0].length > 0
          amplification = response[0].length.to_f / stats_cmd.length.to_f
          
          if amplification > @service_thresholds["Memcached"][:amplification_factor]
            confidence = amplification > 10 ? "High" : "Medium"
            
            @results[:vulnerable_services] << {
              port: 11211,
              service: "Memcached",
              issue: "Vulnerable to Memcached amplification (Factor: #{amplification.round(1)}x)"
            }
            
            @results[:potential_attacks] << {
              type: "Memcached Amplification",
              port: 11211,
              service: "Memcached",
              details: "Memcached UDP amplification factor of #{amplification.round(1)}x detected.",
              confidence: confidence
            }
          end
        else
          # Try TCP if UDP didn't respond
          begin
            socket = TCPSocket.new(target, 11211)
            socket.puts("stats\r\n")
            
            response_lines = []
            5.times do
              line = socket.gets
              break unless line
              response_lines << line
            end
            
            socket.close
            
            if response_lines.any? { |line| line.include?("STAT") }
              @results[:vulnerable_services] << {
                port: 11211,
                service: "Memcached",
                issue: "Accessible Memcached server (potential for abuse)"
              }
              
              @results[:potential_attacks] << {
                type: "Memcached Exploitation",
                port: 11211,
                service: "Memcached",
                details: "Memcached server accessible without authentication.",
                confidence: "Medium"
              }
            end
          rescue => e
            # Error in testing
          end
        end
      rescue => e
        # Error in testing
      end
    end
    
    # Check for SSDP amplification vulnerability (port 1900)
    if open_ports.include?(1900)
      puts "[*] Testing SSDP for amplification vulnerabilities...".blue
      begin
        socket = UDPSocket.new
        socket.connect(target, 1900)
        
        # M-SEARCH request that would be used in amplification
        msearch = "M-SEARCH * HTTP/1.1\r\nHOST: 239.255.255.250:1900\r\nMAN: \"ssdp:discover\"\r\nMX: 1\r\nST: ssdp:all\r\n\r\n"
        socket.send(msearch, 0)
        
        response = nil
        begin
          Timeout.timeout(2) do
            response = socket.recvfrom(4096)
          end
        rescue Timeout::Error
          # No response received
        end
        
        socket.close
        
        if response && response[0].length > 0
          amplification = response[0].length.to_f / msearch.length.to_f
          
          if amplification > @service_thresholds["SSDP"][:amplification_factor]
            confidence = amplification > 8 ? "High" : "Medium"
            
            @results[:vulnerable_services] << {
              port: 1900,
              service: "SSDP",
              issue: "Vulnerable to SSDP amplification (Factor: #{amplification.round(1)}x)"
            }
            
            @results[:potential_attacks] << {
              type: "SSDP Amplification",
              port: 1900,
              service: "SSDP",
              details: "SSDP amplification factor of #{amplification.round(1)}x detected.",
              confidence: confidence
            }
          end
        end
      rescue => e
        # Error in testing
      end
    end
  end
  
  def calculate_risk_level
    # Calculate overall risk level based on findings
    attack_count = @results[:potential_attacks].size
    high_confidence_attacks = @results[:potential_attacks].count { |attack| attack[:confidence] == "High" }
    
    # Critical attacks - check if particularly dangerous DoS vectors are present
    critical_attacks = ["DNS Amplification", "NTP Amplification", "Memcached Amplification", "SSDP Amplification"]
    has_critical = @results[:potential_attacks].any? do |attack| 
      critical_attacks.include?(attack[:type]) && attack[:confidence] == "High"
    end
    
    # Calculate weighted score
    score = 0
    @results[:potential_attacks].each do |attack|
      # Base score
      attack_score = case attack[:type]
                     when "DNS Amplification", "NTP Amplification", "Memcached Amplification", "SSDP Amplification"
                       3
                     when "Slowloris", "Connection Exhaustion"
                       2
                     else
                       1
                     end
      
      # Apply confidence multiplier
      multiplier = case attack[:confidence]
                   when "High"
                     1.0
                   when "Medium"
                     0.6
                   else
                     0.3
                   end
      
      score += attack_score * multiplier
    end
    
    # Determine risk level based on final score
    if has_critical && high_confidence_attacks >= 1 && score >= 5
      @results[:summary][:risk_level] = "Critical"
      @results[:summary][:is_vulnerable] = true
    elsif score >= 3 || high_confidence_attacks >= 2
      @results[:summary][:risk_level] = "High"
      @results[:summary][:is_vulnerable] = true
    elsif score >= 1.5 || attack_count >= 2
      @results[:summary][:risk_level] = "Medium"
      @results[:summary][:is_vulnerable] = true
    elsif attack_count >= 1
      @results[:summary][:risk_level] = "Low"
      @results[:summary][:is_vulnerable] = true
    else
      @results[:summary][:risk_level] = "Low"
      @results[:summary][:is_vulnerable] = false
    end
  end
  
  def generate_recommendations
    # Generate recommendations based on findings
    if @results[:potential_attacks].any?
      @results[:summary][:recommendations] << "Implement rate limiting and connection throttling on all public-facing services."
      
      # Web server specific recommendations
      if @results[:potential_attacks].any? { |a| a[:type] == "Slowloris" || a[:type] == "HTTP/HTTPS Flood" }
        @results[:summary][:recommendations] << "Configure web server to limit concurrent connections per IP and implement connection timeout policies."
        @results[:summary][:recommendations] << "Consider implementing a web application firewall (WAF) to filter malicious traffic."
      end
      
      # DNS specific recommendations
      if @results[:potential_attacks].any? { |a| a[:type] == "DNS Amplification" }
        @results[:summary][:recommendations] << "Configure DNS server to disable recursive queries from external sources or implement response rate limiting."
      end
      
      # NTP specific recommendations
      if @results[:potential_attacks].any? { |a| a[:type] == "NTP Amplification" }
        @results[:summary][:recommendations] << "Update NTP server and disable monlist command or restrict to trusted IPs only."
      end
      
      # General recommendations for all vulnerable services
      @results[:summary][:recommendations] << "Deploy DoS protection services or hardware (e.g., DDoS mitigation appliances, CDN services)."
      @results[:summary][:recommendations] << "Implement ingress filtering at network edge to drop spoofed packets."
      @results[:summary][:recommendations] << "Consider implementing SYN cookies and TCP connection validation."
    else
      @results[:summary][:recommendations] << "Continue monitoring for new vulnerabilities and maintain current security posture."
    end
  end
end
